#
# ==============
# storage.sk v0.0.20
# ==============
# Let players create efficient storage units without the need to building big hopper storage systems.
# ==============
# Dependencies
# ==============
# > Spigot 1.13.2 - https://hub.spigotmc.org/jenkins/job/BuildTools/
# > Skript by bensku - https://github.com/SkriptLang/Skript/releases
# > skript-mirror - https://github.com/btk5h/skript-mirror/releases
# > SKQuery - https://www.spigotmc.org/resources/unofficial-skquery-fork-1-6-1-12.36631/
# ==============
# How to use it:
# ==============
# > First use: Put this skript into your "plugins/Skript/scripts/" Folder, subfolders are possible too.
# ==============
# > Edit options as you want, the options are explained using comments to help.
# ==============
# > Players can craft storage units using a recipe out of 8 diamonds and one chest
# > in the middle of the crafting table and then place it to use:
# > diamond | diamond | diamond
# > diamond |  chest  | diamond
# > diamond | diamond | diamond
# ==============

options:
  #
  # > Define how the storage item should be named.
  itemidentfier: &eStorage
  #
  # > Define the storage block. It is suggested to only use any shulker box,
  # > because this add-on doesn't handle double chest behaviour.
  item: white shulker box
  #
  # > Define, how many times in ticks the storage menus should be updated, the more often
  # > they get updated, the more fluent it looks. But at cost of performance.
  updatemenu: 4
  #
  # > Kick player out of the storage menu after a specific amount of idling in there
  # > to prevent used resources from checking for updates.
  kickafteridle: 200
  #
  # > Define the sign format to give players the option to create a sign above the
  # > storage unit, which displays the item type and amount of stored items. Should be unique.
  signtext: [Storage]
  #
  # > Defines if Minecarts with inventory can be used to fill and empty storage units,
  # > which enables players to set up efficient item sorting machines.
  minecartactions: true
  #
  # > Set a text which has to be placed on the 4th line of a storage sign to interact with
  # > minecarts above the sign. One for the "fill" and one for the "empty" action.
  signfilltext: FILL
  signemptytext: EMPTY
  #
  # > Set an item which should trigger the storage unit fill and empty event. The minecart
  # > has to roll over this defined block to trigger a fill or empty event.
  minecarttriggerevent: gold block
  #
  # > Hook into hoppers. This may take many resources, disable this if you experience too much
  # > lag by the InventoryMoveItemEvent event, disable Hook into hoppers to reduce the lag.
  # > Please communicate with your players that you're going to disable the hopper hook, since
  # > players are going to be mad if you don't tell them. You should thell them that this is
  # > done because it creates lag.
  hopperhook: true
  #
  # > Prevent hoppers below storage units. This is useful since hoppers below storage units will try
  # > to pull out the storage clay out of the storage unit. This generates lag even if there are no
  # > items transported. It is suggested to turn this feature off but you can enable it to allow some
  # > fancy storage systems. Beware that this can cause problems if hoppers are handled asynchronous
  # > if set to false. Storage units could get corrupted.
  preventhopperbelow: true
  #
  # > Fallback translations, if there is no translation available, use this:
  prefix: &7[&6Storage&7]
  menutitle: Storage unit
  hopperbelowdisabled: Hopper transfer out of storage units is disabled.
  onlybreakempty: You can only break empty storage units.
  notenoughinvspace: Not enough space in your inventory.
  storeintitle: Store
  storeinmenu: &7Store everything of this\n&7item in the storage unit.
  getoutmenu: &7Get <max> out of\n&7the storage unit.\n&7--------\n&7Supply: <supply>

#
# > Import the Java class to detectt the inventory move event. This is used very often and
# > causes lag. Server operators who experience lags should avoid this type of events or reduce
# > the allowed amount of hoppers.
import:
  org.bukkit.event.inventory.InventoryMoveItemEvent
  org.bukkit.event.vehicle.VehicleMoveEvent
  org.bukkit.Bukkit
  java.text.DecimalFormat
  org.bukkit.Material
  org.bukkit.inventory.ItemStack

#
# > Event - on InventoryMoveItemEvent
# > Triggered if a item is moved in any inventory on the server.
# > Actions:
# > Counts up or down, depending if the storage unit gets an item or a hopper takes
# > one out of it. If the option {@hopperhook} is set to false, all inventory interactions
# > with hoppers are disabled.
on InventoryMoveItemEvent:
  #
  # > If the server operator disabled hoppers for the storage units, cancel the events.
  if {@hopperhook} is false:
    if slot 26 of event.getDestination() is clay:
      if line 2 of lore of slot 26 of event.getDestination() is "STORAGE":
        event.setCancelled(true)
        stop
  if {@preventhopperbelow} is true:
    if slot 26 of event.getSource() is clay:
      if line 2 of lore of slot 26 of event.getSource() is "STORAGE":
        event.setCancelled(true)
        stop
  #
  # > If the storage unit is the destination of the item.
  if slot 26 of event.getDestination() is clay:
    set {_inv} to event.getDestination()
    set {_itemdata} to slot 26 of {_inv}
    #
    # > If this chest is a valid storage unit.
    if line 2 of lore of {_itemdata} is "STORAGE":
      set {_item} to slot 0 of {_inv}
      set {_itemdata} to slot 26 of {_inv}
      set {_eitem} to event.getItem()
      #
      # > If the storage unit is empty, the {_item} is air.
      if {_item} is air:
        if "%{_eitem}%" contains "shulker":
          event.setCancelled(true)
          stop
        set line 1 of lore of slot 26 of {_inv} to "1"
        set {_loc} to event.getDestination().getHolder().getLocation()
        storagesignupdater({_loc},{_item},1)
      #
      # > If the {_item} is the same as the event item (the one, which is added through the hopper),
      # > add it to the storage unit.
      else if {_item} is {_eitem}:
        #
        # > Set {_amount} to the amount of storage unit items in the inventory of
        # > the storage unit.
        set {_amount} to number of {_item} in {_inv}
        #
        # > There is always one of the item left to keep NBT data. Since one has been
        # > added by the event, remove one now.
        remove 1 of {_item} from {_inv}
        #
        # > Get the current storage amount.
        set {_savedamount} to line 1 of lore of {_itemdata}
        set {_savedamount} to {_savedamount} parsed as integer
        #
        # > Add the new amount to the storage amount.
        add {_amount} to {_savedamount}
        #
        # > Save the storage amount back to the item lore.
        set line 1 of lore of {_itemdata} to "%{_savedamount}%"
        #
        # > Get the location of the chest to update the storage sign.
        set {_loc} to event.getDestination().getHolder().getLocation()
        storagesignupdater({_loc},{_item},{_savedamount})
        #
        # > Set the new item lore to the storage unit.
        set slot 26 of {_inv} to 64 of {_itemdata}
      #
      # > If the hopper tries to move a item into the storage unit which
      # > doesn't match with the storage item, check, if there are any
      # > other matching items in the hopper.
      else:
        #
        # > Cancel the event here, if there is a valid item,
        # > remove it manually out of the hopper.
        event.setCancelled(true)
        #
        # > Get the hopper as a variable.
        set {_hopper} to event.getSource().getHolder()
        #
        # > Prevent item glich bugs by waiting 1 tick.
        wait 1 tick
        loop all items in {_hopper}'s inventory:
          if 1 of loop-item is 1 of {_item}:
            #
            # > Remove 1 of the item out of the hopper.
            remove 1 of {_item} from {_hopper}'s inventory
            #
            # > Get the current storage amount.
            set {_savedamount} to line 1 of lore of {_itemdata}
            set {_savedamount} to {_savedamount} parsed as integer
            #
            # > Add 1 to the storage amount.
            add 1 to {_savedamount}
            #
            # > Save the new value back to the lore
            set line 1 of lore of {_itemdata} to "%{_savedamount}%"
            #
            # > Get the location of the chest to update the storage sign.
            set {_loc} to event.getDestination().getHolder().getLocation()
            storagesignupdater({_loc},{_item},{_savedamount})
            #
            # > Set the new item lore to the storage unit.
            set slot 26 of {_inv} to 64 of {_itemdata}
            #
            # > Stop the loop if one valid item has been found.
            stop loop
        #
        # > Delete the hopper and stop this event execution here.
        delete {_hopper}
        stop
  else:
    #
    # > If the storage unit is the source of the item.
    if slot 26 of event.getSource() is clay:
      set {_inv} to event.getSource()
      #
      # > If the storage unit is empty, cancel and stop.
      if line 1 of lore of slot 26 of {_inv} is "0":
        event.setCancelled(true)
        stop
      #
      # > If the storage unit is valid.
      if line 2 of lore of slot 26 of {_inv} is "STORAGE":
        #
        # > If the hopper tries to get the clay which holds storage unit data, cancel and stop.
        set {_eitem} to event.getItem()
        if {_eitem} is clay:
          if line 2 of lore of {_eitem} is "STORAGE":
            event.setCancelled(true)
            stop
        #
        # > Set the clay item which holds the storage unit data as local variable.
        set {_itemdata} to slot 26 of {_inv}
        #
        # > Get the current amount of items in the storage amount,
        # > parse it as integer and check if it is equal or less than 0.
        # > If it is equal or less than 0, cancel and stop.
        set {_savedamount} to line 1 of lore of {_itemdata}
        set {_savedamount} to {_savedamount} parsed as integer
        if {_savedamount} <= 0:
          event.setCancelled(true)
          stop
        #
        # > If it is not equal or less than 0, remove 1 from the storage unit amount.
        else:
          remove 1 from {_savedamount}
          set line 1 of lore of {_itemdata} to "%{_savedamount}%"
          set {_loc} to {_inv}.getHolder().getLocation()
          #
          # > Update the storage sign.
          storagesignupdater({_loc},{_item},{_savedamount})
          set slot 26 of {_inv} to 64 of {_itemdata}
          #
          # > Clone the current item in slot 0 of the storage unit.
          set {_item} to 1 of slot 0 of {_inv}
          set {_item} to {_item}.clone()
          #
          # > Wait one tick until the hopper has pulled the item out of the
          # > storage unit.
          wait 1 tick
          #
          # > After one tick, the hopper has pulled the item out, add one to
          # > the storage unit to save NBT data and item data.
          if {_savedamount} > 0:
            add 1 of {_item} to {_inv}
          #
          # > If the saved storage unit amount is 0, set the slot 0 to air.
          else if {_savedamount} is 0:
            set slot 0 of {_inv} to air
  
#
# > Event - on inventory click
# > Action:
# > Prevent the storage item to be clicked in inventory and remove it + log it.
on inventory click:
  if event-item.getType() is Material.CLAY_BALL!:
    if line 2 of lore of event-item is "STORAGE":
      log "%player% %event-item% %line 1 of lore of event-item%" to "storageitemused"
      set event-slot to air
      cancel event

#
# > Event - on load
# > Action:
# > After loading this skript, the recipe to create storage units is registered.
on load:
  set {_item} to {@item}
  set line 1 of lore of {_item} to "{@itemidentfier}"
  wait 20 seconds
  addShapedRecipe({_item}, diamond, diamond, diamond, diamond, chest, diamond, diamond, diamond, diamond)

#
# > Event - on dispense of option (item)
# > Triggered if a dispenser places the predefined storage item.
# > Actions:
# > Checks if the dispensed item is a valid storage unit, if it is,
# > the event gets cancelled. Storage units have to be placed by hand.
on dispense of {@item}:
  if storageitemcheck(event-item) is true:
    cancel event

#
# > Event - on place of option (item)
# > Triggered if the player places the predefined storage item.
# > Actions:
# > If the player is allowed to build at the island, create a storage unit.
on place of {@item}:
  #
  # > Only check for hoppers if this item is a valid storage unit.
  if line 1 of lore of player's tool is "{@itemidentfier}":
    #
    # Check, if the player is allowed to place the storage unit.
    set {_allowed} to checkislandaccess(player,location of event-block,"build")
    if {_allowed} is true:
      #
      # > If the block below the new storage unit is a hopper, check if it is allowed
      # > to have a hopper below. If not, cancel event and send message to player.
      if block below event-location is hopper:
        if {@preventhopperbelow} is true:
          cancel event
          set {_lang} to getlangcode(player)
          if getlang("storage_hopperbelowdisabled",{_lang}) is set:
            set {_msg} to getlang("storage_hopperbelowdisabled",{_lang})
            set {_prefix} to getlang("prefix",{_lang})
            message "%{_prefix}% %{_msg}%"
          else:
            message "{@prefix} {@hopperbelowdisabled}"
          stop
      #
      # > The player is allowed, place clay in the slot 26 of the chest and set
      # > the lore of the clay to line 1: 0, line 2: "STORAGE". Line 1 is the amount of items.
      # > If a item is stored, it is always on slot 0.
      set {_loc} to event-location
      set {_inv} to block at {_loc}'s inventory
      set slot 26 of {_inv} to 64 of clay
      set line 1 of lore of slot 26 of {_inv} to "0"
      set line 2 of lore of slot 26 of {_inv} to "STORAGE"
  #
  # > Minecraft 1.14 no longer stores the inventory of the shulker boxes as it
  # > has been done before. Checking the inventory of new shulker boxes
  # > to prevent corrupted storage units.
  else:
    loop all items in the inventory of event-block:
      if loop-item is clay:
        if line 2 of lore of loop-item is "STORAGE":
          if loop-slot is not 26:
            set slot 26 of inventory of event-block to 64 of loop-item
            set loop-item to air
            stop

#
# > Event - on place of any shulker box
# > Triggered if a player places not a predefined storage unit.
# > Actions:
# > If a player places a shulker box which shouldn't be a storage unit but
# > somehow got one through bugs, this will prevent the shulker box from
# > being placed down.
on place of any shulker box:
  if event-block is not {@item}:
    loop all items in the inventory of event-block:
      if loop-item is clay:
        if line 2 of lore of loop-item is "STORAGE":
          cancel event

#
# > Event - on break of option (item)
# > Triggered if the player breaks a storage unit.
# > Actions:
# > If the player is allowed to build at the island and the broken storage unit is empty,
# > remove and drop it.
on break of {@item}:
  #
  # > Only check if this is a valid storage unit.
  if slot 26 of event-block's inventory is clay:
    if line 2 of lore of slot 26 of event-block's inventory is "STORAGE":
      #
      # > Check, if the player is allowed to build.
      set {_allowed} to checkislandaccess(player,location of event-block,"build")
      if {_allowed} is true:
        #
        # > Check, if the storage unit is empty to remove it.
        set {_itemdata} to slot 26 of event-block's inventory
        set {_savedamount} to line 1 of lore of {_itemdata}
        set {_savedamount} to {_savedamount} parsed as integer
        #
        # > If the storage unit is not empty (because line 1 of the clay has not been parsed as integer 1),
        # > send a error and cancel the event.
        if {_savedamount} is not 0:
          set {_lang} to getlangcode(player)
          if getlang("storage_onlybreakempty",{_lang}) is set:
            set {_msg} to getlang("storage_onlybreakempty",{_lang})
            set {_prefix} to getlang("prefix",{_lang})
            message "%{_prefix}% %{_msg}%"
          else:
            message "{@prefix} {@onlybreakempty}"
          cancel event

#
# > Event - on place of hopper
# > Triggered if the player places a hopper.
# > Actions:
# > If the player places a hopper below a storage unit and it should be
# > prevented to place hoppers below storage units, the event is canceled
# > and the player gets a message that this is disabled.
on place of hopper:
  if block above event-location is {@item}:
    set {_inv} to block at block above event-location's inventory
    set {_itemdata} to slot 26 of {_inv}
    if line 2 of lore of {_itemdata} is "STORAGE":
      if {@preventhopperbelow} is true:
        cancel event
        set {_uuid} to uuid of {_p}
        set {_lang} to getlangcode({_p})
        if getlang("storage_hopperbelowdisabled",{_lang}) is set:
          set {_msg} to getlang("storage_hopperbelowdisabled",{_lang})
          set {_prefix} to getlang("prefix",{_lang})
          message "%{_prefix}% %{_msg}%"
        else:
          message "{@prefix} {@hopperbelowdisabled}"

#
# > Event - VehicleMoveEvent
# > Triggered if a minecart moves.
# > Actions:
# > If the minecartt moves over a predefined block, trigger the
# > storage unit fill and empty events, which allow minecarts to
# > either fill or empty the storage units with a minecart.
on VehicleMoveEvent:
  #
  # > The server operator can disable the minecart storage unit triggers,
  # > check if it has been disabled.
  if {@minecartactions} is not true:
    stop
  #
  # > Check if the block below the minecarts destination is a predefined trigger
  # > for the fill and empty event of the storage units.
  if block 1 below event.getTo() is {@minecarttriggerevent}:
    #
    # > Get the location of the block which is 2 blocks below the minecart where it is going to move.
	# > This will be the sign of the storage unit.
    set {_loc} to location of block 2 below event.getTo()
    #
    # > Only go forward, if the sign is a valid storage sign.
    if line 1 of block at {_loc} is "&l{@signtext}":
      #
      # > Only go forward, if the sign has a mode set to it, which is either FILL or EMPTY (predefined in options).
      if line 4 of block at {_loc} is "{@signfilltext}" or "{@signemptytext}":
        #
        # > Set the mode to a variable, since it is needed later.
        set {_mode} to line 4 of block at {_loc}
        #
        # > Remove 1 of the y-coordinate from the {_loc} variable, which then has the
        # > location of the storage unit, if there is one.
        remove 1 from y-coord of {_loc}
        #
        # > Check, if there is actually a storage unit.
        if slot 26 of block at {_loc}'s inventory is clay:
          if line 2 of lore of slot 26 of block at {_loc}'s inventory is "STORAGE":
            #
            # > Prevent the minecart from interacting with the same storage unit
            # > twice in a row by checking if the metadata value "lastblock" of the
            # > vehicle is the same as the location of the block.
            if metadata value "lastblock" of event.getVehicle() is not {_loc}:
              #
              # > If this storage unit is unique, set the locaction of it 
              # > to the metadata value "lastblock" of the vehicle.
              set metadata value "lastblock" of event.getVehicle() to {_loc}
              #
              # > Get the item which is currently in the storage unit as variable.
              set {_item} to slot 0 of block at {_loc}'s inventory
              #
              # > Only try check for transfers if the item isn't air.
              if {_item} is not air:
                #
                # > If the mode of the storage unit is set to get filled by minecarts.
                if {_mode} is "{@signfilltext}":
                  #
                  # > Loop the inventory of the minecart for matching items.
                  loop all items in event.getVehicle()'s inventory:
                    #
                    # > If one of the looped items is the same as the one stored, go forward.
                    if 1 of loop-item is 1 of {_item}:
                      #
                      # > Get the currently stored amount of the storage unit to update it properly.
                      set {_savedamount} to line 1 of lore of slot 26 of block at {_loc}'s inventory
                      set {_savedamount} to {_savedamount} parsed as integer
                      #
                      # > Add the amount to the storage amount.
                      add number of loop-item in event.getVehicle()'s inventory to {_savedamount}
                      #
                      # > Remove all of the loop items from the vehicle.
                      remove all loop-item from event.getVehicle()'s inventory
                      #
                      # > Set the update variable to true to later update the storage and sign.
                      set {_update} to true
			    #
			    # > If the mode of the storage unit is set to get emptied by minecarts.
                else if {_mode} is "{@signemptytext}":
                  #
                  # > Get the amount of air left in the minecart, which can be filled with stuff.
                  set {_amount} to number of air in event.getVehicle()'s inventory
                  #
                  # > If the amount is bigger than 0, multiply it by the amount of the maximum stack size of the item.
                  if {_amount} > 0:
                    set {_amount} to {_item}.getMaxStackSize() * {_amount}
                  #
                  # > Get the currently saved amount of the storage unit and parse it as integer.
                  set {_savedamount} to line 1 of lore of slot 26 of block at {_loc}'s inventory
                  set {_savedamount} to {_savedamount} parsed as integer
                  #
                  # > If there is more saved in the storage unit than the minecart can hold.
                  if {_savedamount} > {_amount}:
                    #
                    # > Remove the amount from the storage amount.
                    remove {_amount} from {_savedamount}
                  #
                  # > If there is not enough in the storage unit to fill up the minecart.
                  else:
                    #
                    # > Leave 1 item in the storage unit to keep the item type.
                    set {_amount} to {_savedamount}-1
                    #
                    # > Remove the amount from the storage amount.
                    remove {_amount} from {_savedamount}
                  #
                  # > Add the items to the inventory of the vehicle.
                  add {_amount} of {_item} to event.getVehicle()'s inventory
                  #
                  # > Set the update variable to true to later update the storage and sign.
                  set {_update} to true
                #
                # > If something has changed, update the storage unit and the storage sign.
                if {_update} is true:
                  #
                  # > Save the storage amount back to the item lore.
                  set line 1 of lore of slot 26 of block at {_loc}'s inventory to "%{_savedamount}%"
                  #
                  # > Get the location of the chest to update the storage sign.
                  storagesignupdater({_loc},{_item},{_savedamount})
                  #
                  # > Delete variables which are no longer needed.
                  delete {_update}
              delete {_item}
        delete {_mode}
    delete {_loc}

#
# > Event - on inventory open
# > Triggered once a player opens a inventory
# > Actions:
# > If the player opened a valid storage unit, call the openstoragemenu function and cancel the event.
on inventory open:
  if block at event-inventory.getHolder().getLocation() is {@item}:
    if slot 26 of event-inventory is clay:
      if line 2 of lore of slot 26 of event-inventory is "STORAGE":
        set {_loc} to block at event-inventory.getHolder().getLocation()
        set {_allowed} to checkislandaccess(player,{_loc},"storageunit",block at {_loc})
        if {_allowed} is true:
          openstoragemenu(player,event-inventory,{_loc})
        cancel event

#
# > Event - on rightclick on sign
# > Triggered once a player clicks on a sign
# > Actions:
# > If the player wants to open a storage unit using the storage status sign, open the storage menu if allowed.
on rightclick on sign:
  if line 1 of event-block is "&l[Storage]":
    #
    # > Get the location of the clicked block and then get the inventory of the
    # > block below, only go forward, if the block below is a valid storage unit.
    set {_storageloc} to location of event-block
    remove 1 from y-coord of {_storageloc}
    set {_storageinv} to inventory of block at {_storageloc}
    if slot 26 of {_storageinv} is clay:
      if line 2 of lore of slot 26 of {_storageinv} is "STORAGE":
        set {_allowed} to checkislandaccess(player,{_storageloc},"storageunit",block at {_storageloc})
        if {_allowed} is true:
          openstoragemenu(player,{_storageinv},{_storageloc})
        cancel event

#
# > Function - storagesignupdater
# > Parameter: <location>location of the storage unit,<item>storage unit item, <integer>current amount of items stored
# > Actions:
# > Updates the storage sign, if the player created one above the storage unit.
# > The storage sign is optional, this function only does something if there is a correctly formatted sign.
function storagesignupdater(loc:location,item:item,amount:integer):
  if block above {_loc} is sign:
    if line 1 of block above {_loc} is "{@signtext}":
      set line 1 of block above {_loc} to "&l{@signtext}"
    if line 1 of block above {_loc} is "&l{@signtext}":
      if {_amount} is 0:
        set {_item} to "---"
      set line 2 of block above {_loc} to "%{_item}%"
      set line 3 of block above {_loc} to "&l%getformattedamount({_amount})%"

#
# > Function - getformattedamount
# > Parameters:
# > <number>the number which should be formatted
# > Actions:
# > Formats a number and returns it as text for display purposes.
function getformattedamount(number:number) :: text:
  #
  # > Set a DecimalFormat depending on the stored amount.
  if {_number} < 1000:
    set {_format} to new DecimalFormat("0")
  else if {_number} >= 1000:
    set {_format} to new DecimalFormat("0,000")
  else if {_number} >= 1000000:
    set {_format} to new DecimalFormat("0,000,000")
  else if {_number} >= 1000000000:
    set {_format} to new DecimalFormat("0,000,000,000")
  #
  # > Return the formatted number as text.
  return {_format}.format({_number})

#
# > Function - openstoragemenu
# > Parameter: <player>the player to who the menu should open,<inventory>storage unit inventory, <location>location of the storage unit
# > Actions:
# > Opens the storage unit menu, which allows players to set up their storage unit, get items out and put it in.
function openstoragemenu(p:player,inv:inventory,loc:location):
  #
  # > Get the stored item data
  set {_item} to slot 0 of {_inv}
  #
  # > Get the storage unit data (amount of item)
  set {_itemdata} to slot 26 of {_inv}
  #
  # > Get the current amount of items stored in the storage unit:
  set {_savedamount} to line 1 of lore of {_itemdata}
  set {_savedamount} to {_savedamount} parsed as integer
  #
  # > Set idle counter to 0, the server operator can configure, how long players
  # > are allowed to idle in the storage unit menus.
  set {_idle} to 0
  #
  # > Open hopper menu to the player.
  set {_uuid} to uuid of {_p}
  set {_lang} to getlangcode({_p})
  if getlang("storage_menutitle",{_lang}) is set:
    opengui({_p},5,getlang("storage_menutitle",{_lang}),hopper inventory)
  else:
    opengui({_p},5,"{@menutitle}",hopper inventory)

  #
  # > If the storage unit is empty, open the "fill it" menu.
  if {_savedamount} is 0:
    set {_cinv} to {_p}'s current inventory
    #
    # > Wait until the player places something in the newly created inventory
    # > by using while.
    while {_cinv} is {_p}'s current inventory:
      #
      # > Since the storage unit can also be updated using hoppers or by other players,
      # > check everytime, if the storage unit has been filled with something.
      set {_itemdata} to slot 26 of {_inv}
      set {_savedamount} to line 1 of lore of {_itemdata}
      set {_savedamount} to {_savedamount} parsed as integer
      #
      # > If the storage unit is still empty, check for items.
      if {_savedamount} is 0:
        #
        # > Loop through all items in the "fill it" menu.
        loop all items in {_p}'s current inventory:
          #
          # > This only happens, if there is a item in the "fill it" menu.
          #
          # > Get the item, which is in the "fill it" menu.
          set {_item} to loop-item
          #
          # > Set the {_item} into the storage unit on slot 0.
          set slot 0 of {_inv} to 1 of {_item}
          #
          # > Add the amount of items in the "fill it" to the storage unit.
          set {_itemdata} to slot 26 of {_inv}
          set {_savedamount} to line 1 of lore of {_itemdata}
          set {_savedamount} to {_savedamount} parsed as integer
          set line 1 of lore of {_itemdata} to "%number of {_item} in {_cinv}%"
          #
          # > Update the storage unit sign.
          set {_amount} to line 1 of lore of {_itemdata} parsed as integer
          set {_signitem} to 1 of {_item}
          storagesignupdater({_loc},{_signitem},{_amount})
          #
          # > Save the new item metadata for the storage unit clay, which holds the amount of the items in
          # > its lore.
          set slot 26 of {_inv} to 64 of {_itemdata}
          #
          # > Reopen the storage unit menu, which should now show the item with options and stop.
          openstoragemenu({_p},{_inv},{_loc})
          stop
        #
        # > If there where no items, add one to idle until timeout closes and stops this.
        add 1 to {_idle}
        if {_idle} > {@kickafteridle}:
          close {_p}'s inventory
          stop
      #
      # > If the storage unit is no longer empty, open the menu with the new item and stop.
      else:
        openstoragemenu({_p},{_inv},{_loc})
        stop

      #
      # > Update the storage unit menu only as often as predefined.
      wait {@updatefirstmenu} tick

    #
    # > Give the items back, if the menu has been closed before it has been cheecked.
    set {_items::*} to all items in {_cinv}
    loop {_items::*}:
      drop loop-value at {_p}
  #
  # > The storage unit has something in it to show.
  else:
    #
    # > Prevent any items from being moved into the slots of the storage unit.
    loop 5 times:
      setguiitem({_p},loop-number - 1,light gray glass pane,1," ",""," ",false)
    #
    # > Get the maximum stack size of the current item stored.
    set {_max} to {_item}.getMaxStackSize()
    #
    # > Check, if the amount of items in this storage unit is smaller than the maximum amount,
    # > if it is smaller, set the maximum amount to the amount of items in this storage unit.
    if {_savedamount} <= {_max}:
      set {_max} to {_savedamount}
    #
    # > Create menu which allows the player to get items out of the storage unit using the getstorageitem function and
    # > store more items directly using the storestorageitem function.
    set {_uuid} to uuid of {_p}
    set {_lang} to getlangcode({_p})
    setguiitem({_p},1,north facing chest,1,"","","getstorageitem(""%{_p}%"" parsed as player,%x-coord of {_loc}%,%y-coord of {_loc}%,%z-coord of {_loc}%)||getstorageitem(""%{_p}%"" parsed as player,%x-coord of {_loc}%,%y-coord of {_loc}%,%z-coord of {_loc}%,true)",false)
    if getlang("storage_storeinmenu",{_lang}) is set:
      set {_title} to getlang("storage_storeintitle",{_lang},"&r")
      set {_lore} to getlang("storage_storeinmenu",{_lang})
      setguiitem({_p},3,north facing chest,1,{_title},{_lore},"storestorageitem(""%{_p}%"" parsed as player,%x-coord of {_loc}%,%y-coord of {_loc}%,%z-coord of {_loc}%)",false)
    else:
      setguiitem({_p},3,north facing chest,1,"&r{@storeintitle}","{@storeinmenu}","storestorageitem(""%{_p}%"" parsed as player,%x-coord of {_loc}%,%y-coord of {_loc}%,%z-coord of {_loc}%)",false)
    #
    # > Clone the storage unit item to place it in the menu.
    set {_item} to {_item}.clone()
    #
    # > The lore of the item, which displays the current supply of items.
    # > Also displays the maximum stack amount which the player gets per click.
    if getlang("storage_getoutmenu",{_lang}) is set:
      set {_lore} to getlang("storage_getoutmenu",{_lang})
    else:
      set {_lore} to "{@getoutmenu}"
    replace all "<max>" with "%{_max}%" in {_lore}
    replace all "<supply>" with getformattedamount({_savedamount}) in {_lore}
    set {_lore::*} to {_lore} split at "\n"
    set lore of {_item} to {_lore::*}
    #
    # > Set the cloned item with the new lore to the newly opened inventory of the player.
    set slot 1 of {_p}'s current inventory to {_item}
    #
    # > Set the current inventory to {_cinv} to check, if the player closed his inventory in the while loop.
    set {_cinv} to {_p}'s current inventory
    #
    # > Set {_startcheck} to the amount of items which are currently stored, if
    # > the amount changes, a update is triggered within the while loop.
    set {_startcheck} to line 1 of lore of slot 26 of {_inv}
    #
    # > Do this while loop as long as the player keeps this inventory open.
    # > If the player closes or changes the inventory, it is no longer the 
    # > same as {_cinv} and is not going to be updated trough the while loop anymore.
    while {_cinv} is {_p}'s current inventory:
      #
      # > Loop only every predefined ticks.
      wait {@updatemenu} tick
      #
      # > Count the idle time to prevent endless looping for a player.
      add 1 to {_idle}
      if {_idle} > {@kickafteridle}:
        close {_p}'s inventory
        stop
      #
      # > If the supply of the storage unit changed, update the inventory of the player.
      if {_startcheck} is not line 1 of lore of slot 26 of {_inv}:
        set {_startcheck} to line 1 of lore of slot 26 of {_inv}
        set {_startcheck} to {_startcheck} parsed as integer
        set {_max} to {_item}.getMaxStackSize()
        if {_startcheck} <= {_max}:
          set {_max} to {_startcheck}
        if getlang("storage_getoutmenu",{_lang}) is set:
          set {_lore} to getlang("storage_getoutmenu",{_lang})
        else:
          set {_lore} to "{@getoutmenu}"
        replace all "<max>" with "%{_max}%" in {_lore}
        replace all "<supply>" with getformattedamount({_startcheck}) in {_lore}
        set {_lore::*} to {_lore} split at "\n"
        set {_item} to slot 1 of {_p}'s current inventory
        set lore of {_item} to {_lore::*}
        set slot 1 of {_p}'s current inventory to {_item}
#
# > Function - getstorageitem
# > Parameter: <player>the player who wants items out of the storage unit,<number>x-coordinate of the storage unit,<number>y-coordinate of the storage unit,<number>z-coordinate of the storage unit,<boolean>get multiple stacks at once[true=yes]
# > Actions:
# > Gives the player parameter items out of the storage unit.
function getstorageitem(p:player,x:number,y:number,z:number,mass:boolean=false):
  #
  # > Create a new location to get the storage unit.
  set {_loc} to location at {_x}, {_y}, {_z} in "%{_p}'s world%" parsed as world
  #
  # > Check if this is a valid storage unit.
  if block at {_loc} is {@item}:
    #
    # > Sets the inventory of the storage unit as local variable.
    set {_inv} to block at {_loc}'s inventory
    #
    # > Set the storage unit clay item which contains the item amount of the storage unit.
    set {_itemdata} to slot 26 of {_inv}
    if line 2 of lore of {_itemdata} is "STORAGE":
      #
      # > As long as we aren't done with giving the player items, repeat this while loop.
      set {_done} to false
      while {_done} is false:
        #
        # > Get the item, which the player should get out of slot 0 of the storage unit.
        set {_item} to slot 0 of {_inv}
        #
        # > Get the currently stored amount of items in the storage unit out of the storage unit clay item on slot 26.
        set {_savedamount} to line 1 of lore of {_itemdata}
        set {_savedamount} to {_savedamount} parsed as integer
        #
        # > Get the maximum stack size of the item, this is needed to give the player the right amount out.
        set {_max} to {_item}.getMaxStackSize()
        #
        # > If the maximum stack size is higher than the current item amount, set the maximum size to the item amount.
        if {_savedamount} <= {_max}:
          set {_max} to {_savedamount}
        #
        # > Remove the item amount from the storage unit.
        remove {_max} from {_savedamount}
        #
        # > If {_max} is 0, there is nothing to get.
        if {_max} is 0:
          #
          # > Since there is nothing to get, we're done here, reopen the menu.
          set {_done} to true
          openstoragemenu({_p},{_inv},{_loc})
          stop
        #
        # > If the player has not enough space in his inventory, tell the player about that.
        if {_p}'s inventory hasn't enough space for {_max} of {_item}:
          #
          # > In any case, we're done, do not proceed with the while loop.
          set {_done} to true
          #
          # > If the player took the items out in big amounts using the mass parameter true, do
          # > not inform about not enough space in inventory and stop.
          if {_mass} is true:
            openstoragemenu({_p},{_inv},{_loc})
            stop
          set {_uuid} to uuid of {_p}
          set {_lang} to getlangcode({_p})
          if getlang("storage_notenoughinvspace",{_lang}) is set:
            set {_prefix} to getlang("prefix",{_lang})
            set {_msg} to getlang("storage_notenoughinvspace",{_lang})
            message "%{_prefix}% %{_msg}%" to {_p}
          else:
            message "{@prefix} {@notenoughinvspace}" to {_p}

          stop
        #
        # > The player has enough space, save the new amount to the storage unit item and
        # > give the player the items.
        set line 1 of lore of {_itemdata} to "%{_savedamount}%"
        storagesignupdater({_loc},{_item},{_savedamount})
        set slot 26 of {_inv} to 64 of {_itemdata}
        if {_savedamount} is 0:
          remove 1 of {_item} from {_inv}
        give {_max} of {_item} to {_p}
        #
        # > If the player doesn't get multiple stacks because of mass = true,
        # > the process is done. We can stop the while loop and reopen the menu
        # > to update the stats.
        if {_mass} is false:
          openstoragemenu({_p},{_inv},{_loc})
          set {_done} to true
#
# > Function - storestorageitem
# > Parameter: <player>the player who wants items out of the storage unit,<number>x-coordinate of the storage unit,<number>y-coordinate of the storage unit,<number>z-coordinate of the storage unit,<boolean>get multiple stacks at once[true=yes]
# > Actions:
# > Gives the player parameter items out of the storage unit.
function storestorageitem(p:player,x:number,y:number,z:number):
  #
  # > Create a new location to get the storage unit.
  set {_loc} to location at {_x}, {_y}, {_z} in "%{_p}'s world%" parsed as world
  #
  # > Only proceed if the storage unit is valid.
  if block at {_loc} is {@item}:
    #
    # > Set the storage unit inventory as local variable.
    set {_inv} to block at {_loc}'s inventory
    #
    # > Set the storage unit clay, which stores the item amount, which is stored in the storage unit.
    set {_itemdata} to slot 26 of {_inv}
    if line 2 of lore of {_itemdata} is "STORAGE":
      #
      # > Get the current amount, which is stored in the storage unit and parse it as integer.
      set {_savedamount} to line 1 of lore of {_itemdata}
      set {_savedamount} to {_savedamount} parsed as integer
      #
      # > Get the item, which is currently stored in the storage unit
      set {_item} to slot 0 of {_inv}
      #
      # > Set {_amount} to the amount of items the player has in his inventory.
      # > These items have to be the same as in slot 0 of the storage unit.
      set {_inventory} to {_p}'s inventory
      set {_amount} to number of {_item} in {_inventory}
      set {_itemlist} to {_inventory}.all({_item}.getType())
      loop ...{_itemlist}.keySet():
        set {_loopitem} to {_itemlist}.get(loop-value)
        {_loopitem}.setAmount(1)
        if {_loopitem} is 1 of {_item}:
          add {_itemlist}.get(loop-value).getAmount() to {_savedamount}
          {_inventory}.setItem(loop-value, new ItemStack(Material.AIR!))	
      #
      # > Add the amount the player wants to add to the storage unit amount and save it to the storage unit clay amount item.
      set line 1 of lore of {_itemdata} to "%{_savedamount}%"
      #
      # > Update the storage sign
      storagesignupdater({_loc},{_item},{_savedamount})
      set slot 26 of {_inv} to 64 of {_itemdata}
      #
      # > Remove the items of the inventory of the player.
      #remove {_amount} of {_item} from {_p}'s inventory
      #
      # > Reopen the storage unit menu to update the menu.
      openstoragemenu({_p},{_inv},{_loc})


#
# > Function - storageitemcheck
# > Parameters: 
# > <item>the item which should be checked for a storage unit
# > Actions:
# > Checks the given block, if it is a storage unit, this function returns true.
function storageitemcheck(item:item) :: boolean:
  #
  # > Check if there is a visible item identifier for a storage unit.
  if line 1 of lore of {_item} is "{@itemidentfier}":
    return true
  #
  # > If it seems that this isn't a storage unit, check the inventory of it.
  else:
    #
    # > If the metadata of this item is set.
    if {_item}.getItemMeta() is set:
      #
      # > Set the metadata to a variable and check if it has a blockstate.
      set {_meta} to {_item}.getItemMeta()
      #
      # > Check if the block state exists before checking for it.
      set {_blockStateSet} to try {_meta}.hasBlockState()
      if {_blockStateSet} is not set:
        return false
      if {_blockStateSet} is false:
        return false
      if {_meta}.getBlockState() is set:
        #
        # > Get the BlockState of the item to check the inventory of the block.
        set {_shulker} to {_meta}.getBlockState()
        set {_inv} to Bukkit.createInventory(null, 27, "1")
        {_inv}.setContents({_shulker}.getInventory().getContents())
        delete {_shulker}
        #
        # > If the 26th slot has clay balls, check if the 2nd line is "STORAGE",
        # > if it is, then this is a storage unit.
        loop 27 times:
          set {_item} to {_inv}.getItem(loop-number - 1)
          if {_item} is clay balls:
            if 2nd line of {_item}'s lore is "STORAGE":
              return true
        delete {_inv}
      delete {_meta}
  delete {_item}
