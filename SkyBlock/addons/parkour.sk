#
# ==============
# parkour.sk v0.0.5
# ==============
# Let players create jump and run parkour. There are start, checkpoint and finish blocks which can
# be placed everywhere it is allowed. Players can also try to get into the toplist by speedrunning
# some parkour if they want to do that.
# ==============
# Dependencies
# ==============
# > Spigot - https://hub.spigotmc.org/jenkins/job/BuildTools/
# > Skript by bensku - https://github.com/SkriptLang/Skript/releases
# > skript-mirror - https://github.com/btk5h/skript-mirror/releases
# > SKQuery - https://www.spigotmc.org/resources/unofficial-skquery-fork-1-6-1-12.36631/
# > SKYBLOCK.SK - https://github.com/Abwasserrohr/SKYBLOCK.SK
# ==============
# How to use it:
# ==============
# > First use: Place parkour.sk into your "plugins/Skript/scripts/" folder and restart. Subfolders are possible too.
# > Commands: /giveparcour <player>
# > Usage for players: Place the blocks and use the inventory of these blocks to get
# > checkpoint and finish blocks. They can be removed using their inventory menu.
# > To disable, simply put a "-" in front of this file name.

#
# > If you want to change the look or settings, here are the options.
# > You can also change the skript itself to work as you want.
options:
  #
  # > Maximum amount of speedrun times saved for each parkour before the slowest gets deleted.
  maxruntimes: 100
  #
  # > This item will be given to the players when they get a parcour
  # > set through the /giveparcour <player> command.
  parcouritem: sticky piston
  #
  # > This is the block which is going to be placed on top of a
  # > parcour block. It has to trigger the block below.
  pressureplate: stone pressure plate
  #
  # > This is the block which stores the parcour data. It needs a inventory
  # > and has to spit out items on a redstone signal.
  parcourblock: upward dropper
  #
  # > This block should be the same as above but without any direction definition.
  parcourblock1: dropper
  #
  # > Define the parcour inventory items for the player.
  itemcheckpoint: floor sign
  itemtoplist: book
  itemrestart: eye of ender
  itemexit: barrier
  #
  # > These are the items which are displayed in the menu, feel free to change
  # > them as you want.
  menuitemcheckpoint: heavy weighted pressure plate
  menuitemfinish: light weighted pressure plate
  menuitembreak: barrier
  #
  # > Fallback translations
  # > The fallback translations are used if there isn't the right
  # > language available for this part of SKYBLOCK.SK.
  guiheader: &lParcour
  prefix: &7[&6Parcour&7]
  checkpointreached: Checkpoint reached
  checkpointinvalid: &4Invalid Checkpoint
  finishinvalid: &4Invalid finish
  itemcheckpointname: &rCheckpoint
  itemrestartname: &rRestart
  itemexitname: &rExit
  itemtoplistname: &rToplist
  parcourunloaded: The parcour has been unloaded. Thank you for playing.
  finishmsg: Congratulations! You have reached the finish.
  yourtime: Your time: <time>
  menucheckpointitemname: Checkpoint Plate
  menufinishitemname: Finish Plate
  menuremoveblockname: Remove this parcour block
  menucheckpointitemlore: Get a checkpoint plate to place.
  menufinishitemlore: Get a finish plate to place.
  menuremoveblocklore: You get it back as item.
  noinventoryinparcour: You can't open inventories while in the parcour.
  parcouritemcheckpoint: &r&eParcour - Checkpoint
  parcouritemfinish: &r&eParcour - Goal
  parcouritemstart: &r&eParcour - Start
  
import:
  java.util.UUID
  java.util.HashMap
  java.util.Date
  java.util.ArrayList
#
# > Commands

#
# > Command - /giveparcour
# > Arguments:
# > <player>the player who should get the parcour block
# > Actions:
# > Gives the player a parcour start block usingg the
# > getparcourtools function, also defined a new
# > random uuid for each newly given out parcour tool start block.
command /giveparcour <player>:
  trigger:
    if executor is not console:
      if executor doesn't have permission "is.admin":
        stop
    set {_parcourid} to UUID.randomUUID()
    getparcourtools(arg-1,3,"%{_parcourid}%")
    
#
# > Command - /checkpoint
# > Actions:
# > If the player wants to get back to the checkpoint,
# > /checkpoint or /cp is teleporting the player
# > back to the last checkpoint.
command /checkpoint:
  aliases: /cp
  trigger:
    if metadata value "parcour" of player is "ingame":
      parcourcheckpoint(player)

#
# > Events

#
# > Event - on dispense of bedrock
# > Actions:
# > If a bedrock gets dispended, it is very likely that this is a parcour
# > bedrock, if the name of the block is also "parcour", the event is
# > cancelled and players in the area are looped to either start a parcour,
# > set a checkpoint or finish the parcour.
on dispense of bedrock:
  if name of event-item is "parcour":
    cancel event
    #
    # > Set some data to a local variable, which is needed
    # > later.
    set {_item} to event-item
    set {_type} to getnbtvalue({_item},"type")
    set {_parcourid} to getnbtvalue({_item},"id")
    set {_loc} to event-location
    add 1 to y-coord of {_loc}
    #
    # > The block is a parcour checkpoint.
    if {_type} is "checkpoint":
      #
      # > Loop around all players within the location.
      loop players in radius 1.5 of {_loc}:
        #
        # > Only continue, if the loop player is within the parcour mode
        # > and has the same parcour id as the block.
        if metadata value "parcour" of loop-player is "ingame":
          if metadata value "parcourid" of loop-player is {_parcourid}:
            set {_blocklocation} to location of event-block
            add 0.5 to y-coord of {_blocklocation}
            #
            # > Get the language code of the player
            set {_lang} to getlangcode(loop-player)
            #
            # > Heal and feed the player.
            healandfeed(loop-player)
            #
            # > If this checkpoint location isn't already set, send a subtitle message.
            if metadata value "checkpoint" of loop-player is not {_blocklocation}:
              #
              # > Check for translation, if not available, use fallback.
              if getlang("parkour_checkpointreached",{_lang}) is not set:
                set {_msg} to "{@checkpointreached}"
              else:
                set {_msg} to getlang("parkour_checkpointreached",{_lang})
              send subtitle "%{_msg}%" to loop-player for 0.5 seconds with fadein 5 tick and fade out 5 tick
            #
            # > Set the new location to the checkpoint metadata of the player.
            set metadata "checkpoint" of loop-player to {_blocklocation}
          #
          # > If the parcour id isn't the same, send a error.
          else:
            #
            # > Check for translation, if not available, use fallback.
            if getlang("parkour_checkpointinvalid",{_lang}) is not set:
              set {_msg} to "{@checkpointinvalid}"
            else:
              set {_msg} to getlang("parkour_checkpointinvalid",{_lang})
            send subtitle "%{_msg}%" to loop-player for 0.5 seconds with fadein 5 tick and fade out 5 tick
    #
    # > The block is a parcour start.
    else if {_type} is "start":
      set {_creatoruuid} to getnbtvalue({_item},"creator")
      set {_creator} to {_creatoruuid} parsed as player
      loop players in radius 1 of {_loc}:
        set {_blocklocation} to location of event-block
        add 0.5 to y-coord of {_blocklocation}
        #
        # > Set the parcour id and the run id to a metadata value on the
        # > player to prevent cheating later.
        set metadata "parcourid" of loop-player to {_parcourid}
        set metadata "runid" of loop-player to UUID.randomUUID()
        set metadata value "%{_parcourid}%-start" of loop-player to new Date()

        #
        # > Get the language code of the player
        set {_lang} to getlangcode(loop-player)
        #
        # > Start the parcour timer.
        startparcourtimer(loop-player,{_parcourid})
        #
        # > If the player has not already activated this start, set a checkpoint
        # > and startpoint there to get back if the player wants.
        if metadata value "checkpoint" of loop-player is not {_blocklocation}:
          set metadata "checkpoint" of loop-player to {_blocklocation}
          set metadata "startpoint" of loop-player to {_blocklocation}
          set metadata "parkourblock" of loop-player to event-block
          if metadata value "parcour" of loop-player is not "ingame":
            saveinventory(loop-player)
            clear loop-player's inventory
            #
            # > Check for translation, if not available, use fallback.
            if getlang("parkour_itemcheckpointname",{_lang}) is not set:
              set {_name1} to "{@itemcheckpointname}"
              set {_name2} to "{@itemrestartname}"
              set {_name3} to "{@itemexitname}"
              set {_name4} to "{@itemtoplistname}"
            else:
              set {_name1} to getlang("parkour_itemcheckpointname",{_lang})
              set {_name2} to getlang("parkour_itemrestartname",{_lang})
              set {_name3} to getlang("parkour_itemexitname",{_lang})
              set {_name4} to getlang("parkour_toplist_item",{_lang})
            set {_item1} to 1 of {@itemcheckpoint} named "%{_name1}%"
            set {_item2} to 1 of {@itemrestart} named "%{_name2}%"
            set {_item3} to 1 of {@itemexit} named "%{_name3}%"
            set {_item4} to 1 of {@itemtoplist} named "%{_name4}%"
            #
            # > Give the player a parcour item inventory to use.
            set slot 0 of loop-player's inventory to {_item1}
            set slot 2 of loop-player's inventory to {_item2}
            set slot 6 of loop-player's inventory to {_item4}
            set slot 8 of loop-player's inventory to {_item3}
          #
          # > Mark the player as parcour player and also set the
          # > game mode to adventure, then heal the player.
          set metadata "parcour" of loop-player to "ingame"
          set gamemode of loop-player to adventure
          healandfeed(loop-player)
    #
    # > The block is a parcour goal.
    else if {_type} is "finish":
      loop players in radius 1 of {_loc}:
        #
        # > Only continue, if the loop player is within the parcour mode
        # > and has the same parcour id as the block.
        if metadata value "parcour" of loop-player is "ingame":
          if metadata value "parcourid" of loop-player is {_parcourid}:
            set {_blocklocation} to location of event-block
            add 0.5 to y-coord of {_blocklocation}
            set {_player} to loop-player
            #
            # > Get the language code of the player
            set {_lang} to getlangcode(loop-player)
            #
            # > Only allow the player to finish the game if it hasn't
            # > been finished by the player a second before.
            if metadata value "checkpoint" of loop-player is not "finish":
              #
              # > Check for translation, if not available, use fallback.
              # > Tell the player that this is the goal.
              if getlang("parkour_finishmsg",{_lang}) is not set:
                message "{@prefix} {@finishmsg}" to loop-player
                set {_msg} to "{@prefix} {@yourtime}"
                replace all "<time>" with getcurrentdifference({_start}, new Date()) in {_msg}
                message {_msg} to loop-player
              #
              # > Get the start date, the current date and calculate the difference in milliseconds.
              set {_start} to metadata value "%{_parcourid}%-start" of loop-player
              set {_now} to new Date()
              set {_diff} to ({_now}.getTime()) - ({_start}.getTime())
              set {_parkourblock} to metadata "parkourblock" of loop-player
              #
              # > parkourtoplist is going to message the player and creates an
              # > toplist entry, if a new personal best time has been made.
              parkourtoplist(loop-player,"newentry",{_parkourblock},{_diff})

              set metadata "checkpoint" of loop-player to "finish"
              delete metadata "%{_parcourid}%-start" of {_player}
              exitparcour(loop-player)
          #
          # > If the parcour id isn't the same, send a error.
          else:
            #
            # > Check for translation, if not available, use fallback.
            if getlang("parkour_finishinvalid",{_lang}) is not set:
              set {_msg} to "{@finishinvalid}"
            else:
              set {_msg} to getlang("parkour_finishinvalid",{_lang})
            #
            # > Send the error as a subtitle.
            send subtitle "%{_msg}%" to loop-player for 2 seconds with fadein 5 tick and fade out 5 tick

#
# > Event - on damage of player
# > Actions:
# > Cancel any damage that occurs to the player while being in a
# > parcour. If the player gets damage by the void, teleport the
# > player back to the checkpoint.
on damage of player:
  if metadata value "parcour" of victim is "ingame":
    cancel event
    if "%damage cause%" is "void":
      parcourcheckpoint(victim)

#
# > Event - on inventory click
# > Actions:
# > To prevent duplication gliches of the parcour items,
# > prevent any inventory clicks while in the parcour.
on inventory click:
  if player's gamemode is adventure:
    if {SK::GUI::inv::%player%} is not set:
      if metadata value "parcour" of player is "ingame":
        cancel event

#
# > Event - on rightclick holding the predefined checkpoint item
# > Actions:
# > If a player is within the parcour, cancel the event and teleport
# > the player back to the checkpoint using the parcourcheckpoint function.
on rightclick holding {@itemcheckpoint}:
  if player's gamemode is adventure:
    if metadata value "parcour" of player is "ingame":
      cancel event
      parcourcheckpoint(player)

#
# > Event - on rightclick holding the predefined checkpoint item
# > Actions:
# > If a player is within the parcour, cancel the event and teleport
# > the player back to the checkpoint using the parcourcheckpoint function.
on rightclick holding {@itemtoplist}:
  if player's gamemode is adventure:
    if metadata value "parcour" of player is "ingame":
      cancel event
      set {_parkourblock} to metadata "parkourblock" of player
      parkourtoplist(player,"toplist",{_parkourblock})

#
# > Event - on rightclick holding the predefined restart item
# > Actions:
# > If a player is within the parcour, cancel the event and teleport
# > the player back to start. Also apply resistance of level 5, which
# > makes the player invulnerable.
on rightclick holding {@itemrestart}:
  if player's gamemode is adventure:
    if metadata value "parcour" of player is "ingame":
      cancel event
      apply potion of resistance of tier 5 to player for 1 second
      set {_checkpoint} to metadata value "startpoint" of player
      teleport player to {_checkpoint}

#
# > Event - on rightclick holding the predefined exit item
# > Actions:
# > If a player is in the adventure gamemode and has a exit item, let the player
# > exit the parcour. The metadata value isn't checked because on server restarts
# > or crashes, the value isn't saved. Also cancel the event.
on rightclick holding {@itemexit}:
  if player's gamemode is adventure:
    cancel event
    exitparcour(player)

#
# > Event - on pickup
# > Actions:
# > If a player wants to pickup items while in the parcour
# > cancel the event to prevent item loss, since the player
# > can't drop anything while in that mode.
on pickup:
  if player's gamemode is adventure:
    if metadata value "parcour" of player is "ingame":
      cancel event

#
# > Event - on drop
# > Actions:
# > If a player wants to drop items while in the parcour
# > cancel the event to prevent parcour items from being
# > duplicated.
on drop:
  if player's gamemode is adventure:
    if metadata value "parcour" of player is "ingame":
      cancel event

#
# > Event - on quit
# > Actions:
# > If a player leaves the game while in a parcour,
# > leave the parcour for the player to prevent
# > inventory loss.
on quit:
  if player's gamemode is adventure:
    if metadata value "parcour" of player is "ingame":
      exitparcour(player)

#
# > Event - on unload
# > Actions:
# > If this skript unloads, throw all players out who
# > are currently in a parcour to restore their inventory
# > to prevent any item loss or faulty behaviour after restart.
on unload:
  loop all players:
    if metadata value "parcour" of loop-player is "ingame":
      #
      # > Get the language code of the player
      set {_lang} to getlangcode(loop-player)
      #
      # > Check for translation, if not available, use fallback.
      if getlang("parkour_parcourunloaded",{_lang}) is not set:
        message "{@prefix} {@parcourunloaded}" to loop-player
      else:
        set {_prefix} to getlang("parkour_parcourunloaded",{_lang})
        set {_msg} to getlang("parkour_parcourunloaded",{_lang})
        message "%{_prefix}% %{_msg}%" to loop-player
      exitparcour(loop-player)

#
# > Event - on inventory open
# > Actions:
# > If the player is in the adventure gamemode and has a metadata value
# > of "ingame" set to the "parcour" tag, cancel the event.
# > If a player opens a inventory with a bedrock in slot 0,
# > which has the name "parcour", it opens the parcour inventory,
# > which allows to break and get more parcour blocks.
on inventory open:
  if player's gamemode is adventure:
    if metadata value "parcour" of player is "ingame":
      #
      # > Get the language code of the player
      set {_lang} to getlangcode(player)
      #
      # > Check for translation, if not available, use fallback.
      if getlang("parkour_noinventoryinparcour",{_lang}) is not set:
        message "{@prefix} {@noinventoryinparcour}"
      else:
        set {_prefix} to getlang("prefix",{_lang})
        set {_msg} to getlang("parkour_noinventoryinparcour",{_lang})
        message "%{_prefix}% %{_msg}%"
      cancel event
  else if slot 0 of event-inventory is bedrock:
    if name of slot 0 of event-inventory is "parcour":
      openparcourinventory(event-inventory,player)
      cancel event

#
# > Event - on place of hopper
# > Actions:
# > To prevent the removal of the bedrock out of the parcours
# > block, hoppers are canceled, if the block above is a parcour block.
on place of hopper:
  set {_blockabove} to block 1 above event-location
  if slot 0 of {_blockabove}'s inventory is bedrock:
    if name of slot 0 of event-inventory is "parcour":
      cancel event
#
# > Event - on break of the predefined pressure plate
# > Actions:
# > If the inventory of the block below the pressure plate has a bedrock in slot 0,
# > cancel the event. Bedrock is not achievable in the game.
on break of {@pressureplate}:
  set {_blockbelow} to block 1 below event-location
  if slot 0 of {_blockbelow}'s inventory is bedrock:
    cancel event
      
#
# > Event - on break of the predefined parcour block
# > Actions:
# > If the inventory of the block has a bedrock in slot 0,
# > cancel the event. Bedrock is not achievable in the game.
on break of {@parcourblock1}:
  if slot 0 of event-block's inventory is bedrock:
    cancel event

#
# > Event - on place of the predefined parcour item
# > Actions:
# > Checks if the item has a specific nbt value for the
# > nbt tag "type", if it has, cancel the vanilla behaviour
# > and place a start|checkpoint|finish parcour block.
on place of {@parcouritem}:
  #
  # > Get the type of the parcour item, if it is one.
  set {_value} to getnbtvalue(player's tool,"type")
  if {_value} is "start" or "finish" or "checkpoint":
    #
    # > This is a valid parcour item block, cancel the event.
    cancel event
    #
    # > If block below is a hopper which could take out items, prevent it.
    if block 1 below event-location is a hopper:
      stop
    #
    # > Get the parcour id of the tool the player is using,
    # > which is the current parcour item block the player
    # > wants to set.
    set {_parcourid} to getnbtvalue(player's tool,"id")
    #
    # > Remove one of the parcour blocks out of the inventory of the player.
    remove 1 of player's tool from player's inventory
    #
    # > Set variables here which are needed below.
    set {_item1} to 1 of {@parcourblock}
    set {_item2} to 1 of {@pressureplate}
    set {_loc} to event-location
    set {_parcourslot} to 1 of bedrock named "parcour"
    #
    # > Place the parcour block at the event-location
    # > Wait 1 tick to allow the placement to happen.
    wait 1 tick
    set block at {_loc} to {_item1}
    #
    # > Set the pressure plate above the new parcour block.
    set block 1 above {_loc} to {_item2}
  #
  # > Set the creator of the parcour here. Also set the type and id of this
  # > parcour block, which is saved in the inventory slot 0 of the block
  # > within a bedrock.
  if {_value} is "start":
    set {_parcourslot} to setnbtvalue({_parcourslot},"creator",uuid of player)
    set {_parcourslot} to setnbtvalue({_parcourslot},"type","start")
    set {_parcourslot} to setnbtvalue({_parcourslot},"id","%{_parcourid}%")
    set slot 0 of block at {_loc} to {_parcourslot}
  else if {_value} is "checkpoint":
    set {_parcourslot} to setnbtvalue({_parcourslot},"type","checkpoint")
    set {_parcourslot} to setnbtvalue({_parcourslot},"id","%{_parcourid}%")
    set slot 0 of block at {_loc} to {_parcourslot}
  else if {_value} is "finish":
    set {_parcourslot} to setnbtvalue({_parcourslot},"type","finish")
    set {_parcourslot} to setnbtvalue({_parcourslot},"id","%{_parcourid}%")
    set slot 0 of block at {_loc} to {_parcourslot}

#
# > Functions

#
# > Function - startparcourtimer
# > Parameters:
# > <player>the player who should get the timer
# > <ttext>the parcour id of the current parcour
# > Actions:
# > Starts a timer for the player and displays the difference between
# > start time and now within the actionbar of the player.
function startparcourtimer(player:player,parcourid:text):
  #
  # > Get the current run id of the player, this id is
  # > unique for every run.
  set {_runid} to metadata value "runid" of {_player}
  #
  # > Save the start time within a local variable and as metadata
  # > tag for the current parcour id.
  set {_start} to new Date()
  set metadata "%{_parcourid}%-start" of {_player} to {_start}
  #
  # > Do a while loop as long as the run id doesn't change.
  while metadata value "runid" of {_player} is {_runid}:
    #
    # > Display the difference between now and the start time in the actionbar.
    set {_difference} to getcurrentdifference({_start}, new Date())
    #
    # > If the difference is higher than 1 hour, stop it,
    # > there is no reason to keep a timer running.
    if difference between now and {_start} > 1 hour:
      stop
    #
    # > Display the time to the player in the actionbar.
    actionbar({_player},"%{_difference}%")
    #
    # > Stop the loop if the player is no longer online.
    if {_player} is offline:
      stop
    #
    # > Repeat the loop every 1 tick.
    wait 1 tick

#
# > Function - exitparcour
# > Parameters:
# > <player>the player who wants to exit the parcour
# > Actions:
# > Throws the player parameter out of the parcour.
function parcourcheckpoint(player:player):
  #
  # > Prevent damage event of any fall with resistance.
  apply potion of resistance of tier 5 to {_player} for 1 second
  #
  # > Teleport player back to the last checkpoint location.
  set {_checkpoint} to metadata value "checkpoint" of {_player}
  teleport {_player} to {_checkpoint}

#
# > Function - exitparcour
# > Parameters:
# > <player>the player who wants to exit the parcour
# > Actions:
# > Throws the player parameter out of the parcour.
function exitparcour(player:player):
  #
  # > Clear the parcour inventory and restore the inventory of the player.
  clear {_player}'s inventory
  restoreinventory({_player})
  #
  # > Delete metadata which marked the player as parcour player.
  delete metadata value "parcour" of {_player}
  delete metadata "checkpoint" of {_player}
  delete metadata "runid" of {_player}
  #
  # > Set the player back to survival mode.
  set gamemode of {_player} to survival

#
# > Function - healandfeed
# > Parameters:
# > <player>the player who should get healed and feeded
# > Actions:
# > Feeds and heals the player
function healandfeed(player:player):
  heal {_player}
  set {_player}'s food level to 10

#
# > Function - saveinventory
# > Parameters:
# > <player>the player who should get the inventory saved
# > Actions:
# > Saves the inventory of the player to variables to restore it later.
function saveinventory(player:player):
  set {_num} to 0
  #
  # > Loop through the inventory of the player to save all slots.
  loop 36 times:
    set {_item} to slot {_num} of {_player}'s inventory
    set {TMP::parcour::%{_player}%::%{_num}%} to {_item}
    add 1 to {_num}
  #
  # > Save the armor, health and hunger of the player.
  set {TMP::parcour::%{_player}%::helmet} to {_player}'s helmet
  set {TMP::parcour::%{_player}%::chestplate} to {_player}'s chestplate
  set {TMP::parcour::%{_player}%::legging} to {_player}'s legging
  set {TMP::parcour::%{_player}%::boots} to {_player}'s boots
  set {TMP::parcour::%{_player}%::offhand} to {_player}'s offhand tool
  set {TMP::parcour::%{_player}%::health} to {_player}'s health
  set {TMP::parcour::%{_player}%::hunger} to {_player}'s hunger

#
# > Function - restoreinventory
# > Parameters:
# > <player>the player who should get the inventory restored
# > Actions:
# > Restores the previously saved inventory.
function restoreinventory(player:player):
  set {_num} to 0
  #
  # > Loop through all the slots the player has and restore the items.
  loop 36 times:
    set slot {_num} of {_player}'s inventory to {TMP::parcour::%{_player}%::%{_num}%}
    delete {TMP::parcour::%{_player}%::%{_num}%}
    add 1 to {_num}
  #
  # > Restone the armor, health and hunger.
  set {_player}'s helmet to {TMP::parcour::%{_player}%::helmet}
  set {_player}'s chestplate to {TMP::parcour::%{_player}%::chestplate}
  set {_player}'s legging to {TMP::parcour::%{_player}%::legging}
  set {_player}'s boots to {TMP::parcour::%{_player}%::boots}
  set {_player}'s offhand tool to {TMP::parcour::%{_player}%::offhand}
  set {_player}'s health to {TMP::parcour::%{_player}%::health}
  set {_player}'s hunger to {TMP::parcour::%{_player}%::hunger}
  #
  # > Delete all restore variables of the player.
  delete {TMP::parcour::%{_player}%::helmet}
  delete {TMP::parcour::%{_player}%::chestplate}
  delete {TMP::parcour::%{_player}%::legging}
  delete {TMP::parcour::%{_player}%::boots}
  delete {TMP::parcour::%{_player}%::offhand}
  delete {TMP::parcour::%{_player}%::health}
  delete {TMP::parcour::%{_player}%::hunger}
  delete {TMP::parcour::%{_player}%::*}
  delete {TMP::parcour::%{_player}%}

#
# > Function - openparcourinventory
# > Parameters:
# > <inventory>the inventory of the current parcour block
# > <player>the player who should get the inventory
# > Actions:
# > Opens the parcour menu
function openparcourinventory(inventory:inventory,player:player):
  #
  # > Get the language code of the player
  set {_lang} to getlangcode({_player})
  #
  # > Get nbt data out of the parcour item.
  set {_item} to slot 0 of {_inventory}
  set {_type} to getnbtvalue({_item},"type")
  set {_parcourid} to getnbtvalue({_item},"id")
  #
  # > Get the location of the current parcour block.
  set {_loc} to {_inventory}.getHolder().getLocation()
  #
  # > Set the current target to a non persistent metadata tag.
  set metadata "targetblock" of {_player} to {_loc}
  #
  # > Check for translation, if not available, use fallback.
  if getlang("parkour_guiheader",{_lang}) is not set:
    set {_msg} to "{@guiheader}"
  else:
    set {_msg} to getlang("parkour_guiheader",{_lang})
  #
  # > Open the menu to the player.
  opengui({_player},27,"%{_msg}%")
  #
  # > Check for translation, if not available, use fallback.
  if {SB::lang::parkour::guiheader::%{_lang}%} is not set:
    set {_checkpointitemname} to "{@menucheckpointitemname}"
    set {_menufinishitemname} to "{@menufinishitemname}"
    set {_menuremoveblockname} to "{@menuremoveblockname}"
    set {_menucheckpointitemlore} to "{@menucheckpointitemlore}"
    set {_menufinishitemlore} to "{@menufinishitemlore}"
    set {_menuremoveblocklore} to "{@menuremoveblocklore}"
  else:
    set {_checkpointitemname} to getlang("parkour_menucheckpointitemname",{_lang})
    set {_menufinishitemname} to getlang("parkour_menufinishitemname",{_lang})
    set {_menuremoveblockname} to getlang("parkour_menuremoveblockname",{_lang})
    set {_menucheckpointitemlore} to getlang("parkour_menucheckpointitemlore",{_lang})
    set {_menufinishitemlore} to getlang("parkour_menufinishitemlore",{_lang})
    set {_menuremoveblocklore} to getlang("parkour_menuremoveblocklore",{_lang})
  #
  # > Fill the Inventory with empty glass panes.
  loop 27 times:
    set slot loop-number - 1 of {_players}'s current inventory to black stained glass pane named " "
  #
  # > Set menu items depending on the type of parcour block.
  if {_type} is "start":
    setguiitem({_player},11,{@menuitemcheckpoint},1,"%{_checkpointitemname}%","%{_menucheckpointitemlore}%","getparcourtools(""%{_player}%"" parsed as player,1,""%{_parcourid}%"")",false)
    setguiitem({_player},13,{@menuitemfinish},1,"%{_menufinishitemname}%","%{_menufinishitemlore}%","getparcourtools(""%{_player}%"" parsed as player,2,""%{_parcourid}%"")",false)
    setguiitem({_player},15,{@menuitembreak},1,"%{_menuremoveblockname}%","%{_menuremoveblocklore}%","breakparcourblock(""%{_player}%"" parsed as player)",true)
  else if {_type} is "checkpoint":
    setguiitem({_player},13,{@menuitembreak},1,"%{_menuremoveblockname}%","%{_menuremoveblocklore}%","breakparcourblock(""%{_player}%"" parsed as player)",true)
  else if {_type} is "finish":
    setguiitem({_player},13,{@menuitembreak},1,"%{_menuremoveblockname}%","%{_menuremoveblocklore}%","breakparcourblock(""%{_player}%"" parsed as player)",true)

#
# > Function - breakparcourblock
# > Parameters:
# > <player>the player who wanted to break the parcour block
# > Actions:
# > Breaks the parcour block and gives the player the block as item back.
function breakparcourblock(player:player):
  set {_loc} to metadata value "targetblock" of {_player}
  set {_item} to slot 0 of block at {_loc}'s inventory
  set {_type} to getnbtvalue({_item},"type")
  set {_parcourid} to getnbtvalue({_item},"id")
  clear block at {_loc}'s inventory
  set block 1 above {_loc} to air
  set block at {_loc} to air
  if {_type} is "checkpoint":
    set {_type} to 1
  else if {_type} is "finish":
    set {_type} to 2
  else if {_type} is "start":
    set {_type} to 3
  getparcourtools({_player},{_type},{_parcourid})

#
# > Function - getparcourtools
# > Parameters:
# > <player>the player who should get the parcour tool
# > <number>the parcour tool number
# > <text>the parcour id
# > Actions:
# > Gives the player paremeter the defined tool.
# > 1 = Checkpoint, 2 = Finish, 3 = Start.
function getparcourtools(player:player,tool:number,parcourid:text):
  #
  # > Get the language code of the player.
  set {_lang} to getlangcode({_player})
  if {_tool} is 1:
    if {SB::lang::parkour::parcouritemcheckpoint::%{_lang}%} is not set:
      set {_item} to 1 of {@parcouritem} named "{@parcouritemcheckpoint}"
    else:
      set {_item} to 1 of {@parcouritem} named getlang("parkour_parcouritemcheckpoint",{_lang})
    set {_item} to setnbtvalue({_item},"type","checkpoint")
    set {_item} to setnbtvalue({_item},"id",{_parcourid})
    add 1 of {_item} to {_player}'s inventory
  else if {_tool} is 2:
    if {SB::lang::parkour::parcouritemfinish::%{_lang}%} is not set:
      set {_item} to 1 of {@parcouritem} named "{@parcouritemfinish}"
    else:
      set {_item} to 1 of {@parcouritem} named getlang("parkour_parcouritemfinish",{_lang})
    set {_item} to setnbtvalue({_item},"type","finish")
    set {_item} to setnbtvalue({_item},"id",{_parcourid})
    add 1 of {_item} to {_player}'s inventory
  else if {_tool} is 3:
    if {SB::lang::parkour::parcouritemstart::%{_lang}%} is not set:
      set {_item} to 1 of {@parcouritem} named "{@parcouritemstart}"
    else:
      set {_item} to 1 of {@parcouritem} named getlang("parkour_parcouritemstart",{_lang})
    set {_item} to setnbtvalue({_item},"type","start")
    set {_item} to setnbtvalue({_item},"id",{_parcourid})
    add 1 of {_item} to {_player}'s inventory

#
# > Function - getcurrentdifference
# > Parameters:
# > <Date>the current date
# > <Date>a date from the past
# > Actions:
# > Creates a string (text) which looks like a stopwatch and returns it.
# > Example: 00:00.000
function getcurrentdifference(now:object,past:object) :: text:
  #
  # > Get the time difference in milliseconds.
  set {_diff} to ({_past}.getTime()) - ({_now}.getTime())
  #
  # > Get the time difference in milliseconds as a text.
  set {_difft} to "%{_diff}%"
  #
  # > Get the length of the text to format the stopwatch.
  set {_length} to length of {_difft}
  #
  # > Split everything into a list.
  set {_difft::*} to {_difft} split at ""
  #
  # > Set the timer which later gets returned.
  set {_timer} to ""
  #
  # > This defines how long the stopwatch timer should be,
  # > 7 allows to display 7 digits.
  set {_loops} to 7
  #
  # > Loop and create the stopwatch like timer.
  while {_done} is not set:
    #
    # > As long as the loops are equal or smaller than the length of the text based
    # > time difference, display a 0.
    if {_loops} <= {_length}:
      add 1 to {_i}
      set {_timer} to "%{_timer}%%{_difft::%{_i}%}%"
    else:
      set {_timer} to "%{_timer}%0"
    #
    # > Depending on the loops, add a ":" or a ".".
    if {_loops} is 6:
      set {_timer} to "%{_timer}%:"
    if {_loops} is 4:
      set {_timer} to "%{_timer}%."
    #
	# > Remove 1 from the loops and stop this while loop once we reached 0 loops.
    remove 1 from {_loops}
    if {_loops} < 1:
      set {_done} to true
  #
  # > Return the stopwatch like timer as a text.
  return {_timer}

#
# > Function - parkourtoplist
# > Parameters:
# > <player>the player who wants to open or create a new entry for the toplist.
# > <text>the action which should be done, either "newentry" or "toplist".
# > <block>the start block of the parkour.
# > <number>the time in milliseconds the player needed.
# > Actions:
# > Either opens a toplist or creates a new entry in the toplist, which is stored within
# > a item nbt serialized.
function parkourtoplist(player:player,action:text,parkourblock:block,diff:number=9999999):
  #
  # > Get the language code and prefix for the player.
  set {_lang} to getlangcode({_player})
  set {_prefix} to getlang("prefix",{_lang})
  #
  # > Get the serialized toplist from the parkour block.
  delete {_times}
  set {_times} to getnbtvalue(slot 0 of {_parkourblock}'s inventory,"timings")
  #
  # > If the toplist exists, then deserialize it, if not, create a new HashMap.
  if {_times} is not false or "" or " ":
    set {_times} to deserialize({_times})
  else:
    set {_times} to new HashMap()
  #
  # > We need the uuid of the player quite often.
  set {_uuid} to uuid of {_player}
  #
  # > If a new entry should be created.
  if {_action} is "newentry":
    #
    # > If the player already is on the toplist.
    if {_times}.get({_uuid}) is set: 
      #
      # > If the old personal best time is slower than the new one,
      # > overwrite the old one and set it to the new time.
      if {_times}.get({_uuid}) > {_diff}:
        set {_oldpb} to {_times}.get({_uuid})
        {_times}.put("%{_uuid}%",{_diff})
        set {_newpb} to true
    #
    # > If the player isn't already on the toplist, simply put the player on there.
    else:
      {_times}.put("%{_uuid}%",{_diff})
      set {_newpb} to true
    #
    # > If a new personal best happened, save it into the parkour block.
    if {_newpb} is true:
      set {_storetimes} to serialize({_times})
      set slot 0 of {_parkourblock}'s inventory to setnbtvalue(slot 0 of {_parkourblock}'s inventory,"timings",{_storetimes})
  #
  # > Create a new list which contains all the keys of the toplist HashMap.
  set {_arraylist::*} to ...new ArrayList({_times}.keySet())
  #
  # > Create a list which can be looped in Skript.
  loop {_arraylist::*}:
    set {_timings::%loop-value%} to {_times}.get(loop-value)
  #
  # > Start sorting the timings list: low to high.
  loop {_timings::*}:
    add 1 to {_size}
    if {_l2h::%loop-value%} is not set:
      set {_l2h::%loop-value%} to loop-index
    else:
      set {_n} to 0
      loop {_size} times:
        add 1 to {_n}
        if {_l2h::%loop-value-1%.%{_n}%} is not set:
          set {_l2h::%loop-value-1%.%{_n}%} to loop-index
          stop loop
  #
  # > Go through the low to high list and create a speedrun toplist.
  loop {_l2h::*}:
    add 1 to {_rank}
    set {_top::%{_rank}%} to loop-value
    if loop-value is {_uuid}:
      set {_playerrank} to {_rank}
  #
  # > If the action is "newentry", tell the player about the new entry with messages.
  if {_action} is "newentry":
    message "%{SB::config::spacer}%" to {_player}
    message "%{_prefix}% %getlang(""parkour_finishmsg"",{_lang})%" to {_player}
    if {_newpb} is true:
      message "%{_prefix}% %getlang(""parkour_personalbest"",{_lang})%" to {_player}
      set {_pbtime} to getlang("parkour_personalbesttime",{_lang})
      set {_oldpbtime} to getlang("parkour_pastpersonalbest",{_lang})
      set {_crank} to getlang("parkour_currentrank",{_lang})
      replace all "<time>" with createstopwatchtimer({_diff}) in {_pbtime}
      replace all "<time>" with createstopwatchtimer({_oldpb}) in {_oldpbtime}
      replace all "<rank>" with "%{_playerrank}%" in {_crank}
      message "%{_prefix}% %{_pbtime}%" to {_player}
      if {_oldpb} is set:
        message "%{_prefix}% %{_oldpbtime}%" to {_player}
      message "%{_prefix}% %{_crank}%" to {_player}
    else:
      set {_pbtime} to getlang("parkour_personalbesttime",{_lang})
      set {_runtime} to getlang("parkour_thisruntime",{_lang})
      set {_crank} to getlang("parkour_currentrank",{_lang})
      replace all "<time>" with createstopwatchtimer({_times}.get({_uuid})) in {_pbtime}
      replace all "<time>" with createstopwatchtimer({_diff}) in {_runtime}
      replace all "<rank>" with "%{_playerrank}%" in {_crank}
      message "%{_prefix}% %getlang(""parkour_nopersonalbest"",{_lang})%" to {_player}
      message "%{_prefix}% %{_runtime}%" to {_player}
      message "%{_prefix}% %{_pbtime}%" to {_player}
      message "%{_prefix}% %{_crank}%" to {_player}
    message "%{SB::config::spacer}%" to {_player}
    #
    # > Loop through the toplist, if it is longer than the predefined
    # > maximum amount of speedrun times, remove the ones which exeed
    # > and are the slowest by deleting the last ranks.
    loop {_top::*}:
      set {_ranking} to loop-index parsed as number
      if {_ranking} > {@maxruntimes}:
        {_times}.remove(loop-value)
        set {_storetimes} to serialize({_times})
        set slot 0 of {_parkourblock}'s inventory to setnbtvalue(slot 0 of {_parkourblock}'s inventory,"timings",{_storetimes})
  #
  # > If the player wants to view the toplist, create a book and open it.
  if {_action} is "toplist":
    #
    # > To create valid books, ComponentBuilder is the fastest way.
    set {_book} to newComponentBuilder()
    #
    # > {_i} is the page counter for the toplist, each page should have 4 entries.
    set {_i} to 0
    #
    # > Loop through the toplist and create the book.
    loop {_top::*}:
      #
      # > On every new site, add the site header.
      if {_i} is 0:
        {_book}.append(newTextComponent(getlang("parkour_toplist_header",{_lang},""," %nl%")))
        {_book}.append(newTextComponent("%{SB::config::bookspacer}%%nl%"))
      #
      # > Convert the times in milliseconds to a better readable format: 00:00.000
      set {_time} to createstopwatchtimer({_timings::%loop-value%})
      {_book}.append(newTextComponent("&l%loop-index%&r | %loop-value parsed as offline player% %nl%>> %{_time}%"))
      {_book}.append(newTextComponent("%{SB::config::bookspacer}%%nl%"))
      add 1 to {_i}
      #
      # > In the case there are not 4 but 5 entries,
      # > {_added} will be checked for that reason
      # > to add the last page, if necessary.
      set {_added} to true
      if {_i} >= 4:
        delete {_added}
        add {_book}.create() to {_sites::*}
        set {_book} to newComponentBuilder()
        set {_i} to 0
    #
    # > If there is one more site needed, add it here.
    if {_added} is true:
      delete {_added}
      add {_book}.create() to {_sites::*}
    #
    # > Create and open the book with the sites using the createopenbook function.
    createopenbook({_player},{_sites::*})

#
# > Function - createstopwatchtimer
# > Parameters:
# > <number>a number as milliseconds
# > Actions:
# > Formats the number into a timer, which should then look like on a stopwatch.
function createstopwatchtimer(diff:number) :: text:
  set {_difft} to "%{_diff}%"
  set {_length} to length of {_difft}
  set {_difft::*} to {_difft} split at ""
  set {_timer} to ""
  set {_loops} to 7
  while {_done} is not set:
    if {_loops} <= {_length}:
      add 1 to {_i}
      set {_timer} to "%{_timer}%%{_difft::%{_i}%}%"
    else:
      set {_timer} to "%{_timer}%0"
    if {_loops} is 6:
      set {_timer} to "%{_timer}%:"
    if {_loops} is 4:
      set {_timer} to "%{_timer}%."
    remove 1 from {_loops}
    if {_loops} < 1:
      set {_done} to true
  return {_timer}

#
# > Function - getcurrentdifference
# > Parameters:
# > <date>the current time (or the one which is in the future of the other one)
# > <date>the past time, which is before the current time.
# > Actions:
# > Returns a stopwatch timer with the calculated time difference between the two dates.
function getcurrentdifference(now:object,past:object) :: text:
  set {_diff} to ({_past}.getTime()) - ({_now}.getTime())
  set {_timer} to createstopwatchtimer({_diff})
  return {_timer}
