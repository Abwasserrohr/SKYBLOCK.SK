

#Is used to leave a island
#use text argument "owner", if the island is deleted by the island owner.
function leaveisland(p:player, text:text):
	clear {_p}'s inventory
	set {_uuid} to uuid of {_p}
	set {_loc} to {SB::player::%{_uuid}%::island::bedrock}
	set {_locx} to x-coord of {_loc}
	set {_locy} to y-coord of {_loc}
	set {_locz} to z-coord of {_loc}
	#todo needs to delete one by one
	delete {SB::player::%{_uuid}%::island::*}
	delete {SB::player::%{_uuid}%::island::leader}
	delete {SB::player::%{_uuid}%::island::border1}
	delete {SB::player::%{_uuid}%::island::border2}
	delete {SB::player::%{_uuid}%::island::bedrock}
	delete {SB::player::%{_uuid}%::island::home::*}		
	teleport {_p} to {SB::config::spawn}

	if {_text} is "owner":
		loop {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::member::*}:
			if loop-value is uuid of {_p}:
				set {_i} to loop-index
				delete {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::member::%{_i}%}
				stop loop
				
#Calculate the island level - executed in a thread
function calcisland(p:player):
	set {_exp} to 0 
	set {_level} to 1
	#set xp needed for next level:
	set {_xpn} to {_level}*{SB::config::explevel}
	set {_uuid} to uuid of {_p}
	loop blocks within {SB::player::%{_uuid}%::island::border1} to {SB::player::%{_uuid}%::island::border2}:
		if loop-block is not void air or air:
			set {_tb} to "%loop-block%" parsed as item
			set {_tb} to "%{_tb}%"
			replace all " " with "_" in {_tb}
			#todo: maybe find another way to do this? looks not good...
			if {_tb} is a chest:
				set {_tb} to "%{_tb}%"
			if {_tb} contains "chest":
				set {_tb} to "chest"
			if {_tb} contains "door":
				set {_tb} to "door"
			if {_tb} contains "plant":
				set {_tb} to "plant"
			if {_tb} contains "fence":
				set {_tb} to "fence"
			if {_tb} contains "cobblestone_wall":
				set {_tb} to "fence"
			if {_tb} contains "slab":
				set {_tb} to "slab"
			if {_tb} contains "leaf":
				set {_tb} to "leaf"
			if {_tb} contains "log":
				set {_tb} to "log"
			if {_tb} contains "grass":
				set {_tb} to "grass"
			if {_tb} contains "furnace":
				set {_tb} to "furnace"
			if {_tb} contains "sapling":
				set {_tb} to "sapling"
			if {_tb} contains "stem":
				set {_tb} to "stem"
			if {_tb} contains "quartz_pillar":
				set {_tb} to "quartz_pillar"
			if {_tb} contains "wool":
				set {_tb} to "wool"
			if {_tb} contains "beacon":
				set {_tb} to "beacon"
			if {_tb} contains "note_block":
				set {_tb} to "note_block"
			if {_tb} contains "jukeboxes":
				set {_tb} to "jukeboxes"
			if {_tb} contains "anvil":
				set {_tb} to "anvil"
			if {_tb} contains "piston":
				set {_tb} to "piston"
			if {_tb} contains "flower_pot":
				set {_tb} to "flower_pot"
			if {_tb} contains "cyan_glass":
				set {_tb} to "glass_block"
			if {_tb} contains "glass_pane":
				set {_tb} to "glass_pane"
			if {_tb} contains "glazed_terracotta":
				set {_tb} to "glazed_terracotta"
			if {_tb} contains "standing_banner":
				set {_tb} to "standing_banner"
			if {_tb} contains "carpet":
				set {_tb} to "carpet"
			if {_tb} contains "bed_head":
				set {_tb} to "bed"
			if {_tb} contains "sandstone_block":
				set {_tb} to "sandstone_block"
			if {_tb} contains "coral_block":
				if {_tb} contains "living":
					set {_tb} to "living_coral_block"
			if {_tb} contains "carpet":
				set {_tb} to "carpet"
			if {_tb} contains "carpet":
				set {_tb} to "carpet"
			if {SB::expblocks::%{_tb}%} is set:
				#add the xp of the block to the exp variable
				add {SB::expblocks::%{_tb}%} to {_exp}
				#if the exp variable is bigger than the xp needed variable, add one level
				if {_exp} is more than {_xpn}:
					add 1 to {_level}
					set {_xpn} to {_level}*{SB::config::explevel}

	set {_bedrockloc} to {SB::player::%{_uuid}%::island::bedrock}
	set {_x} to x-coordinate of {_bedrockloc}
	set {_y} to y-coordinate of {_bedrockloc}
	set {_z} to z-coordinate of {_bedrockloc}
	set {SB::island::%{_x}%_%{_y}%_%{_z}%::level} to {_level}
	delete {SB::calcstatus::%{_p}%}

#Check, if the player is the island owner or member - usedd by checkprotect
function checkislandowner(l:location, p:player) :: text:
	set {_uuid} to uuid of {_p}
	set {_loc1} to {SB::player::%{_uuid}%::island::border1}
	add 1 to x-coord of {_loc1}
	add 1 to z-coord of {_loc1}
	set {_loc2} to {SB::player::%{_uuid}%::island::border2}
	if {_l} is not within {_loc1} to {_loc2}:
		return "false"
	else:
		return "true"

#Check, if a detailed check is needed - used by checkprotect
function generaleventcheck(p:player) :: text:
	if "%{_p}'s world%" is "%{SB::config::world}%":
		if {_p} has permission "%{SB::config::buildpermission}%":
			stop
		set {_uuid} to uuid of {_p}
		if {SB::player::%{_uuid}%::island::border1} is not set:
			return "false"
		else:
			return "true"
#Checks, if the player is allowed to build at the location, false = allowed, true = not allowed	
function checkprotect(l:location,p:player) :: text:
	set {_r} to generaleventcheck({_p})
	if {_r} is "false":
		protectionmgs({_p})
		return {_r}
	else if {_r} is "true":
		set {_r} to checkislandowner({_l}, {_p})
		if {_r} is "false":
			protectionmgs({_p})
		return {_r}
	else:
		return "true"

#Prints message to player
function protectionmgs(p:player):
	set {_uuid} to uuid of {_p}
	set {_prefix} to {SB::lang::prefix::%{SK::lang::%{_uuid}%}%}
	set {_a} to {SB::lang::protect::%{SK::lang::%{_uuid}%}%}
	message "%{_prefix}% %{_a}%" to {_p}
	#todo change this into a action bar to prevent spam: execute console command "/title %{_p}% actionbar {""text"":""%{_prefix}% %{_a}%""}"

#Prints tellraw message to player, on which the player can click and execute a command
function tellrawmsg1(p:player,t1:text,t2:text,c:text):
	execute console command "/tellraw %{_p}% ["""",{""text"":""%{_t1}% ""},{""text"":""%{_t2}%"",""clickEvent"":{""action"":""run_command"",""value"":""%{_c}%""}}]"

#Deletes the island of the defined player
function deleteisland(p1: player):
	set {_prefix} to {SB::lang::prefix::%{Language::%{_p1}%}%}
	set {_uuid} to uuid of {_p1}
	if {SB::player::%{_uuid}%::island::leader} is uuid of {_p1}:
		clear {_p1}'s inventory

		teleport {_p1} to {SB::config::spawn}

		set {_loc} to {SB::player::%{_uuid}%::island::bedrock}
		set {_locx} to x-coord of {_loc}
		set {_locy} to y-coord of {_loc}
		set {_locz} to z-coord of {_loc}
		set {_member::*} to {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::member::*}

		delete {SB::island::%{_locx}%_%{_locy}%_%{_locz}%}
		delete {SB::islvl::%{_locx}%_%{_locy}%_%{_locz}%}
		set {_loc1} to {SB::player::%{_uuid}%::island::border1}
		set {_loc2} to {SB::player::%{_uuid}%::island::border2}

		delete {SB::player::%{_uuid}%::island::leader}
		delete {SB::player::%{_uuid}%::island::border1}
		delete {SB::player::%{_uuid}%::island::border2}
		delete {SB::player::%{_uuid}%::island::bedrock}
		delete {SB::player::%{_uuid}%::island::home::*}		

		loop {_member::*}:
			set {_p} to "%loop-value%" parsed as offline player
			if {_p} is online:
				make {_p} execute command "/is leave"
			else:
				#this is the uuid, not the player name!:
				set {_uuid} to uuid of {_p}
				set {Leave.%{_uuid}%} to true
		set {_a} to {SB::lang::deledtedis::%{Language::%{_p1}%}%}
		message "%{_prefix}% %{_a}%" to {_p1}
		set {_loop} to 0
		set {Islanddelete.%{_p1}%} to true
		set {_size} to size of {deleteisland.1::*}
		add 1 to {_size}
		set {deleteisland.1::%{_size}%} to {_loc1}
		set {deleteisland.2::%{_size}%} to {_loc2}
		delete {Islanddelete.%{_p1}%}
	else:
		set {_a} to {SB::lang::notallowed::%{Language::%{_p1}%}%}
		message "%{_prefix}% %{_a}%" to {_p1}

#Loading bar in actionbar and result
function actionload(p: player, t:text):
	if {_t} is "start":
		set {SB::actionload::%{_p}%} to 1
		set {_vs} to "&6█&7█████████"
		while {SB::actionload::%{_p}%} is set:
			if {_vs} is "&6█&7█████████": 
				set {_s} to "&7[&r%{_vs}%&7]&r" 
				execute console command "/title %{_p}% actionbar {""text"":""%{_vs}%""}"
				wait 0.2 seconds
			replace all "&6█&7█" with "&7█&6█&7" in {_vs}
			set {_s} to "&7[&r%{_vs}%&7]&r" 
			execute console command "/title %{_p}% actionbar {""text"":""%{_vs}%""}"
			if {_vs} is "&7█&7█&7█&7█&7█&7█&7█&7█&7█&6█&7":
				set {_vs} to "&6█&7█████████"
			wait 0.2 seconds
	else:
		delete {SB::actionload::%{_p}%}
		set {_s} to "&6█████████&r %{_t}% &6█████████"
		loop 8 times:
			replace all "&6██" with "&6█" in {_s}
			execute console command "/title %{_p}% actionbar {""text"":""%{_s}%""}"
			wait 10 ticks
		execute console command "/title %{_p}% actionbar {""text"":""""}"


#Opens the menu for the skyblock command: /is
# > Function - skyblockgui:
# > Arguments:
# > <player>player
# > Actions:
# > Opens a new inventory menu with gui.sk
function skyblockgui(p: player):
	#open chest with 3 rows named "&b&lSkyBlock" to {_p}
	opengui({_p},27,"&b&lSkyBlock")
	#Fill the Inventory with empty glass panes:
	loop 3 * 9 times:
		set slot loop-number - 1 of {_p}'s current inventory to black stained glass pane named " "
	#Render the items into the menu
	set {_uuid} to uuid of {_p}
	if {SB::player::%{_uuid}%::island::border1} is set:
		setguiitem({_p},10,"grass",1,"%{SB::lang::guigrassname::%{SK::lang::%{_uuid}%}%}%","","make ""%{_p}%"" parsed as player execute command ""/is home""",true)
	else:
		setguiitem({_p},10,"grass",1,"%{SB::lang::guigrassname::%{SK::lang::%{_uuid}%}%}%","","make ""%{_p}%"" parsed as player execute command ""/is create""",true)
	setguiitem({_p},11,"experience bottle",1,"%{SB::lang::guiexpname::%{SK::lang::%{_uuid}%}%}%","","make ""%{_p}%"" parsed as player execute command ""/is level""",true)
	setguiitem({_p},12,"book and quill",1,"%{SB::lang::guichallangename::%{SK::lang::%{_uuid}%}%}%","","message ""Challenges are coming soon!"" to ""%{_p}%"" parsed as player",true)
	setguiitem({_p},13,"wall sign",1,"%{SB::lang::guitopname::%{SK::lang::%{_uuid}%}%}%","","make ""%{_p}%"" parsed as player execute command ""/is top""",true)
	setguiitem({_p},14,"ender chest",1,"%{SB::lang::guirewardsname::%{SK::lang::%{_uuid}%}%}%","","message ""Rewards are coming soon!"" to ""%{_p}%"" parsed as player",true)
	setguiitem({_p},15,"end portal frame",1,"%{SB::lang::guihubname::%{SK::lang::%{_uuid}%}%}%","","make ""%{_p}%"" parsed as player execute command ""/is spawn""",true)
	setguiitem({_p},16,"barrier",1,"%{SB::lang::guisoonname::%{SK::lang::%{_uuid}%}%}%","","make ""%{_p}%"" parsed as player execute command ""/is level""",true)
	
#This deletes variables and creates new ones on the startup:
#Prevents old variables from being in the system
function loadconfig():
	delete {SB::schematics::*}
	delete {SB::calcdown::*}
	delete {SB::oregenc::*}
	delete {SB::oregen::*}

# > Function - searchbedrock:
# > Arguments:
# > <player>player
# > Actions:
# > Goes trough all possible island locations and check if player's location is within a calculated island,
# > if no island matches, the function returns a location with y-coordinate -5.
function searchbedrock(p:player) :: location:
	#
	# > Here, {_loc} is set to the center of the map, which is always at x0.5, yconfigured height, z0.5 and in a configured world.
	# > This also gets parsed as a world to make it a valid location.
	#
	set {_loc} to location at 0.5, {SB::config::height}, 0.5 in "%{SB::config::world}%" parsed as world
	#
	# > The {_search} variable is for the while loop, once this is deleted or changed, the while loop stops.
	#
	set {_search} to true
	#
	# > The {_s} variable is important to run trough all islands in a organized way.
	# > Since the loop searches for a specific location on a 2D map, it has to find the next point
	# > to check, {_s} tells what should happen next within the while loop.
	#
	set {_s} to 1
	#
	# > The {_l} variable is here to set the amount of times the loop (within the while loop) should
	# > be executed, the {_l} variable is changed within the while loop if the destination was not found.
	#
	set {_l} to 1
	#
	# > The {_distance} variable is set to a local variable and defines the radius of
	# > the island, it is multiplicated by 2 and used to determine the right island size,
	# > distances between islands and protections. Here know which bedrock is nearest
	# > to the specified player.
	#
	set {_distance} to {SB::config::distance}
	#
	# > Start the while loop as long as the local {_search} variable is set to true.
	#
	while {_search} is true:
		#
		# > Counting how many islands are already been searched:
		#
		add 1 to {_i}
		#
		# > If the specified player ({_p} variable) is not online, stop here,
		# > since the location of the specified player is necessary to determine the right bedrock.
		#
		if {_p} is not online:
			delete {_search}
			stop
		#
		# > Loop trough the following code as many times as defined in {_l}. 
		#
		loop {_l} times:
			#
			# > If the {_s} variable is 1 or 5, add the {_distance}*2 to the z- and x-coordinate.
			# > Example, at the beginning, we are at the x like you can view below, then
			# > if {_s} is 1 or 5, we're adding the {_distance}*2 to x and z coordinate.
			# > Every "*" is a island, "x" is the center, where we start, example: server lobby.
			# > Now, if {_s} is 1 or 5, the added {_distance}*2 points to "N", our new island location
			# > which we calculated:
			# > X
			# > ^
			# > | *  *  *  *  *
			# > | *  *  *  N  *
			# > | *  *  x  *  *
			# > | *  *  *  *  *
			# > | *  *  *  *  *
			# > #-------------> Z
			# > (Each "*" is {_distance}*2)
			if {_s} is 1 or 5:
				add ({_distance}*2) to z-coord of {_loc}
			#
			# > If {_s} is 2, we add {_distance}*2 to the x-coordinate, like this:
			# > X
			# > ^
			# > | *  *  *  N  *
			# > | *  *  *  x  *
			# > | *  *  *  *  *
			# > | *  *  *  *  *
			# > | *  *  *  *  *
			# > #-------------> Z
			#
			if {_s} is 2:
				add  ({_distance}*2) to x-coord of {_loc}
			#
			# > If {_s} is 3, we remove {_distance}*2 from the z-coordinate of the location:
			# > X
			# > ^
			# > | *  *  N  x  *
			# > | *  *  *  *  *
			# > | *  *  *  *  *
			# > | *  *  *  *  *
			# > | *  *  *  *  *
			# > #-------------> Z
			#
			if {_s} is 3:
				subtract  ({_distance}*2) from z-coord of {_loc}
			#
			# > If {_s} is 4, we remove {_distance}*2 from the x-coordinate of the location:
			# > X
			# > ^
			# > | *  *  x  *  *
			# > | *  *  N  *  *
			# > | *  *  *  *  *
			# > | *  *  *  *  *
			# > | *  *  *  *  *
			# > #-------------> Z
			#
			if {_s} is 4:
				subtract  ({_distance}*2) from x-coord of {_loc}
			#
			# > With the if statements above, we can control the scan process very easy by changing the
			# > {_s} variable, since this is a while loop, we just change the variable at the end,
			# > and then it gets executed again with the new local {_s} variable.
			#
			
			#
			# > The {_loc} is a new island location, this is where the bedrock of the island.
			# > To be sure that we're not within a protected border or somewhere else, there
			# > is a variable created (array/list), which is set to the location twice.
			# 
			set {_lc::1} to {_loc}
			set {_lc::2} to {_loc}
			#
			# > Here, it is calculated, how big the island actually is, by setting the variables
			# > to point A and B. This is a 3D Model. We take the lowest point on the one corner and
			# > the highest point on the other corner to check, if the player is within this selected area.
			#
			add ({_distance} - {SB::config::protect}) to x-coord of {_lc::1}
			add ({_distance} - {SB::config::protect}) to z-coord of {_lc::1}
			subtract ({_distance} - {SB::config::protect}) from x-coord of {_lc::2}
			subtract ({_distance} - {SB::config::protect}) from z-coord of {_lc::2}
			set y-coord of {_lc::1} to 256
			set y-coord of {_lc::2} to 0
			#
			# > If the player is actually in this space, we return the location of the bedrock and
			# > delete the {_search} variable to stop the while loop from doing more loops.
			#
			if location of {_p} is within {_lc::1} to {_lc::2}:
				return {_loc}
				delete {_search}
		#
		# > We're here if we couldn't find the right island we wanted, now we try to find it
		# > by changing the {_s} variable and looping through this code above again,
		# > we can go trough all islands until we have it found.
		# > Now lets visualise to make it easier to understand what this is actually doing:
		#
		# > If {_s} is 6, it is changed back to 2, this does the following in the next loop cycle:
		# > (x is the old island, N the new island location)
		# > X
		# > ^
		# > | *  *  *  N  *
		# > | *  *  *  x  *
		# > | *  *  *  *  *
		# > | *  *  *  *  *
		# > | *  *  *  *  *
		# > #-------------> Z
		#
		if {_s} is 6:
			set {_s} to 2
		#
		# > If {_s} is not 6, add 1 to {_s} and go forward, if it is 4 after 1 was added, it does the following:
		# > (x is the old island, N the new island location)
		# > X
		# > ^
		# > | *  *  x  *  *
		# > | *  *  N  *  *
		# > | *  *  *  *  *
		# > | *  *  *  *  *
		# > | *  *  *  *  *
		# > #-------------> Z
		#
		else:
			add 1 to {_s}
		#
		# > If {_s} is either 3 or 5, add 1 to {_l} to loop once more.
		# > The loop within the while loop is going to looped one more time to go one step further.
		if {_s} is 3 or 5:
			add 1 to {_l}
		#
		# > To make this whole process more visible how it would look in action, i made the same like above
		# > and visualised it with integers. 1 = first, 9 = last island of this example being calculated.
		# > (x is the lobby at X=0,Z=0)
		# > X
		# > ^
		# > | *  *  *  *  *
		# > | *  4  3  2  *
		# > | *  5  x  1  *
		# > | *  6  7  8  9
		# > | *  *  *  *  *
		# > #-------------> Z
		#
		# > If we're seaching already for more islands than there are, stop it and return a error.
		#
		if {_i} is bigger than size of {SB::islvl::*}:
			#
			# > Delete {_search} to stop the while loop.
			#
			delete {_search}
			#
			# > Set a new location with a y-coordinate of -5, which is a error. The return has
			# > to be a location, that is why we're not returning false.
			#
			set {_loc} to location at 5, -5, 5 in "%{SB::config::world}%" parsed as world
			return {_loc}
