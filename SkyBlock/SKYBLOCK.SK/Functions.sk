#				
# > Function: leaveisland
# > Arguments:
# > <player>player, <text>text
# > Actions:
# > Leaves an island, if the text argument is "ower", it removes all other members from the members list
function leaveisland(p:player, text:text):
	clear {_p}'s inventory
	set {_uuid} to uuid of {_p}
	delete {Leave.%{_uuid}%}
	if {_p} is not online:
		set {Leave.%{_uuid}%} to true
	set {_loc} to {SB::player::%{_uuid}%::island::bedrock}
	set {_locx} to x-coord of {_loc}
	set {_locy} to y-coord of {_loc}
	set {_locz} to z-coord of {_loc}
	#todo needs to delete one by one
	delete {SB::player::%{_uuid}%::island::leader}
	delete {SB::player::%{_uuid}%::island::border1}
	delete {SB::player::%{_uuid}%::island::border2}
	delete {SB::player::%{_uuid}%::island::bedrock}
	loop {SB::player::%{_uuid}%::island::home::*}:
		delete {SB::player::%{_uuid}%::island::home::%loop-index%}
	delete {SB::player::%{_uuid}%::island::home::*}
	delete {SB::player::%{_uuid}%::island::*}
	teleport {_p} to {SB::config::spawn}
	if {_text} is "owner":
		loop {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::member::*}:
			if loop-value is uuid of {_p}:
				set {_i} to loop-index
				delete {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::member::%{_i}%}
				stop loop
#				
# > Function: calcisland
# > Arguments:
# > <player>player
# > Actions:
# > Calculates the island level by getting both borders on the island, then looping though all blocks and
# > calculating all predefined experience bonuses from the configuration together to get a level.
#
function calcisland(p:offline player):
	set {_exp} to 0 
	set {_level} to 1
	#set xp needed for next level:
	set {_xpn} to {_level}*{SB::config::explevel}
	set {_uuid} to uuid of {_p}
	loop blocks within {SB::player::%{_uuid}%::island::border1} to {SB::player::%{_uuid}%::island::border2}:
		if loop-block is not void air or air:
			set {_tb} to "%loop-block%" parsed as item
			set {_tb} to "%{_tb}%"
			replace all " " with "_" in {_tb}
			#todo: maybe find another way to do this? looks not good...
			if {_tb} is a chest:
				set {_tb} to "%{_tb}%"
			if {_tb} contains "chest":
				set {_tb} to "chest"
			if {_tb} contains "door":
				set {_tb} to "door"
			if {_tb} contains "plant":
				set {_tb} to "plant"
			if {_tb} contains "fence":
				set {_tb} to "fence"
			if {_tb} contains "cobblestone_wall":
				set {_tb} to "fence"
			if {_tb} contains "slab":
				set {_tb} to "slab"
			if {_tb} contains "leaf":
				set {_tb} to "leaf"
			if {_tb} contains "log":
				set {_tb} to "log"
			if {_tb} contains "grass":
				set {_tb} to "grass"
			if {_tb} contains "furnace":
				set {_tb} to "furnace"
			if {_tb} contains "sapling":
				set {_tb} to "sapling"
			if {_tb} contains "stem":
				set {_tb} to "stem"
			if {_tb} contains "quartz_pillar":
				set {_tb} to "quartz_pillar"
			if {_tb} contains "wool":
				set {_tb} to "wool"
			if {_tb} contains "beacon":
				set {_tb} to "beacon"
			if {_tb} contains "note_block":
				set {_tb} to "note_block"
			if {_tb} contains "jukeboxes":
				set {_tb} to "jukeboxes"
			if {_tb} contains "anvil":
				set {_tb} to "anvil"
			if {_tb} contains "piston":
				set {_tb} to "piston"
			if {_tb} contains "flower_pot":
				set {_tb} to "flower_pot"
			if {_tb} contains "cyan_glass":
				set {_tb} to "glass_block"
			if {_tb} contains "glass_pane":
				set {_tb} to "glass_pane"
			if {_tb} contains "glazed_terracotta":
				set {_tb} to "glazed_terracotta"
			if {_tb} contains "standing_banner":
				set {_tb} to "standing_banner"
			if {_tb} contains "carpet":
				set {_tb} to "carpet"
			if {_tb} contains "bed_head":
				set {_tb} to "bed"
			if {_tb} contains "sandstone_block":
				set {_tb} to "sandstone_block"
			if {_tb} contains "coral_block":
				if {_tb} contains "living":
					set {_tb} to "living_coral_block"
			if {_tb} contains "carpet":
				set {_tb} to "carpet"
			if loop-block is a hopper:
				add 1 to {_hopper}
			if {SB::expblocks::%{_tb}%} is set:
				#add the xp of the block to the exp variable
				add {SB::expblocks::%{_tb}%} to {_exp}
				#if the exp variable is bigger than the xp needed variable, add one level
				if {_exp} is more than {_xpn}:
					add 1 to {_level}
					set {_xpn} to {_level}*{SB::config::explevel}

	set {_bedrockloc} to {SB::player::%{_uuid}%::island::bedrock}
	set {_x} to x-coordinate of {_bedrockloc}
	set {_y} to y-coordinate of {_bedrockloc}
	set {_z} to z-coordinate of {_bedrockloc}
	set {SB::island::%{_x}%_%{_y}%_%{_z}%::level} to {_level}
	#
	# > Updates the hopper count to the new counted amount of hoppers:
	set {_tmp} to hoppercounter({_p},"update",{_hopper})
	delete {SB::calcstatus::%{_p}%}

#Check, if the player is the island owner or member - usedd by checkprotect
function checkislandowner(l:location, p:player) :: text:
	set {_uuid} to uuid of {_p}
	set {_loc1} to {SB::player::%{_uuid}%::island::border1}
	add 1 to x-coord of {_loc1}
	add 1 to z-coord of {_loc1}
	set {_loc2} to {SB::player::%{_uuid}%::island::border2}
	if {_l} is not within {_loc1} to {_loc2}:
		return "false"
	else:
		return "true"

#Check, if a detailed check is needed - used by checkprotect
function generaleventcheck(p:player) :: text:
	if "%{_p}'s world%" is "%{SB::config::world}%":
		if {_p} has permission "%{SB::config::buildpermission}%":
			stop
		set {_uuid} to uuid of {_p}
		if {SB::player::%{_uuid}%::island::border1} is not set:
			return "false"
		else:
			return "true"
#Checks, if the player is allowed to build at the location, false = allowed, true = not allowed	
function checkprotect(l:location,p:player) :: text:
	set {_r} to generaleventcheck({_p})
	if {_r} is "false":
		protectionmgs({_p})
		return {_r}
	else if {_r} is "true":
		set {_r} to checkislandowner({_l}, {_p})
		if {_r} is "false":
			protectionmgs({_p})
		return {_r}
	else:
		return "true"
#
# > Function: protectionmgs
# > Actions:
# > Prints a error message to the player that this area is protected.
#
function protectionmgs(p:player):
	set {_uuid} to uuid of {_p}
	set {_prefix} to {SB::lang::prefix::%{SK::lang::%{_uuid}%}%}
	set {_a} to {SB::lang::protect::%{SK::lang::%{_uuid}%}%}
	actionload({_p}, {_a})

#
# > Function: tellrawmsg1
# > Arguments:
# > <player>player, <text>text, <text>clickable text, <text>command
# > Actions:
# > Sends the player a clickable text message which executes a command on click.
#
function tellrawmsg1(p:player,t1:text,t2:text,c:text):
	execute console command "/tellraw %{_p}% ["""",{""text"":""%{_t1}% ""},{""text"":""%{_t2}%"",""clickEvent"":{""action"":""run_command"",""value"":""%{_c}%""}}]"

#
# > Function: deleteisland
# > Arguments:
# > <offline player>player
# > Actions:
# > Deletes the island of the defined player, also offline players are possible
function deleteisland(p1: offline player):
	set {_prefix} to {SB::lang::prefix::%{Language::%{_p1}%}%}
	set {_uuid} to uuid of {_p1}
	if {SB::player::%{_uuid}%::island::leader} is uuid of {_p1}:
		clear {_p1}'s inventory

		teleport {_p1} to {SB::config::spawn}
		
		#
		# > If the player is not online, add a variable to delete the inventory once the
		# > player joins the game
		if {_p1} is not online:
			set {Leave.%{_uuid}%} to true

		#
		# > Remove all trusted players from the island:
		loop {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::trust::*}:
			delete {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::trust::%loop-index%}
		delete {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::trust::*}
		delete {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::trust}
		
		#
		# > Delete all available flags for the island:
		loop {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::flag::*}:
			delete {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::flag::%loop-index%}
		delete {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::flag::*}
		delete {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::flag}
		
		#
		# > Remove size upgrades from an island:
		delete {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::sizeupgrade}
		
		#
		# > Remove home upgrades from an island:
		delete {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::homeupgrade}
		
		#
		# > Remove hopper upgrades from an island:
		delete {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::hopperupgrade}
		
		#
		# > Remove the hopper count of the island:
		delete {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::hoppercount}

		set {_loc} to {SB::player::%{_uuid}%::island::bedrock}
		set {_locx} to x-coord of {_loc}
		set {_locy} to y-coord of {_loc}
		set {_locz} to z-coord of {_loc}
		set {_member::*} to {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::member::*}

		#
		# > Delete all homes of the island:
		loop {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::home::*}:
			delete {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::home::%loop-index%}
		delete {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::home::*}
		delete {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::home}

		delete {SB::island::%{_locx}%_%{_locy}%_%{_locz}%}
		delete {SB::islvl::%{_locx}%_%{_locy}%_%{_locz}%}
		set {_loc1} to {SB::player::%{_uuid}%::island::border1}
		set {_loc2} to {SB::player::%{_uuid}%::island::border2}

		delete {SB::player::%{_uuid}%::island::leader}
		delete {SB::player::%{_uuid}%::island::border1}
		delete {SB::player::%{_uuid}%::island::border2}
		delete {SB::player::%{_uuid}%::island::bedrock}
		delete {SB::player::%{_uuid}%::island::home::*}		

		loop {_member::*}:
			set {_p} to "%loop-value%" parsed as offline player
			if {_p} is online:
				make {_p} execute command "/is leave"
			else:
				#this is the uuid, not the player name!:
				set {_uuid} to uuid of {_p}
				set {Leave.%{_uuid}%} to true
		set {_a} to {SB::lang::deledtedis::%{Language::%{_p1}%}%}
		message "%{_prefix}% %{_a}%" to {_p1}
		set {_loop} to 0
		set {Islanddelete.%{_p1}%} to true
		set {_size} to size of {deleteisland.1::*}
		add 1 to {_size}
		set {deleteisland.1::%{_size}%} to {_loc1}
		set {deleteisland.2::%{_size}%} to {_loc2}
		delete {Islanddelete.%{_p1}%}
	else:
		set {_a} to {SB::lang::notallowed::%{Language::%{_p1}%}%}
		actionload({_p1}, {_a})

#Loading bar in actionbar and result
function actionload(p: player, t:text):
	if {_t} is "start":
		set {SB::actionload::%{_p}%} to 1
		set {_vs} to "&6█&7█████████"
		while {SB::actionload::%{_p}%} is set:
			if {_vs} is "&6█&7█████████": 
				set {_s} to "&7[&r%{_vs}%&7]&r" 
				execute console command "/title %{_p}% actionbar {""text"":""%{_vs}%""}"
				wait 0.2 seconds
			replace all "&6█&7█" with "&7█&6█&7" in {_vs}
			set {_s} to "&7[&r%{_vs}%&7]&r" 
			execute console command "/title %{_p}% actionbar {""text"":""%{_vs}%""}"
			if {_vs} is "&7█&7█&7█&7█&7█&7█&7█&7█&7█&6█&7":
				set {_vs} to "&6█&7█████████"
			wait 0.2 seconds
	else:
		delete {SB::actionload::%{_p}%}
		set {_s} to "&6█████████&r %{_t}% &6█████████"
		loop 8 times:
			replace all "&6██" with "&6█" in {_s}
			execute console command "/title %{_p}% actionbar {""text"":""%{_s}%""}"
			wait 10 ticks
		execute console command "/title %{_p}% actionbar {""text"":""""}"


#Opens the menu for the skyblock command: /is
# > Function - skyblockgui:
# > Arguments:
# > <player>player
# > Actions:
# > Opens a new inventory menu with gui.sk
function skyblockgui(p: player):
	#open chest with 3 rows named "&b&lSkyBlock" to {_p}
	opengui({_p},27,"&b&lSkyBlock")
	#Fill the Inventory with empty glass panes:
	loop 3 * 9 times:
		set slot loop-number - 1 of {_p}'s current inventory to black stained glass pane named " "
	#Render the items into the menu
	set {_uuid} to uuid of {_p}
	if {SB::player::%{_uuid}%::island::border1} is set:
		setguiitem({_p},10,"grass",1,"%{SB::lang::guigrassname::%{SK::lang::%{_uuid}%}%}%","","make ""%{_p}%"" parsed as player execute command ""/is home""",true)
	else:
		setguiitem({_p},10,"grass",1,"%{SB::lang::guigrassname::%{SK::lang::%{_uuid}%}%}%","","make ""%{_p}%"" parsed as player execute command ""/is create""",true)
	setguiitem({_p},11,"experience bottle",1,"%{SB::lang::guiexpname::%{SK::lang::%{_uuid}%}%}%","","make ""%{_p}%"" parsed as player execute command ""/is level""",true)
	setguiitem({_p},12,"book and quill",1,"%{SB::lang::guichallangename::%{SK::lang::%{_uuid}%}%}%","","message ""Challenges are coming soon!"" to ""%{_p}%"" parsed as player",true)
	setguiitem({_p},13,"wall sign",1,"%{SB::lang::guitopname::%{SK::lang::%{_uuid}%}%}%","","make ""%{_p}%"" parsed as player execute command ""/is top""",true)
	setguiitem({_p},14,"ender chest",1,"%{SB::lang::guirewardsname::%{SK::lang::%{_uuid}%}%}%","","message ""Rewards are coming soon!"" to ""%{_p}%"" parsed as player",true)
	setguiitem({_p},15,"end portal frame",1,"%{SB::lang::guihubname::%{SK::lang::%{_uuid}%}%}%","","make ""%{_p}%"" parsed as player execute command ""/is spawn""",true)
	setguiitem({_p},16,"jungle leaves",1,"&r&6&l%{SB::lang::bc::changebiomeheader::%{SK::lang::%{_uuid}%}%}%","&r%{SB::lang::bc::changebiomemenulore::%{SK::lang::%{_uuid}%}%}%","biomemenu(""%{_p}%"" parsed as player)",true)

# > Function - biomemenu:
# > Arguments:
# > <player>player
# > Actions:
# > Opens the biome menu to the player where it is possible to get biomes for a fixed, predefined price,
# > define biomes and prices in the config.sk or alter this function like you want.
function biomemenu(p: player):
	#
	# > Open this menu (gui) only for the island owner
	set {_uuid} to uuid of {_p}
	if {SB::player::%{_uuid}%::island::leader} is uuid of {_p}:
		#
		# > Count how many lines are needed:
		set {_size} to size of {SB::config::biome::menuitem::*}
		set {_slots} to 9
		loop 5 times:
			if {_size} is bigger than {_slots}:
				add 9 to {_slots}

		#
		# > Open a menu to the defined player, with the calculated slots and the translated menu header
		opengui({_p},{_slots},"&l%{SB::lang::bc::changebiomeheader::%{SK::lang::%{_uuid}%}%}%")
		#
		# > Fill the inventory with empty glass panes to make it look nicer
		loop {_slots} times:
			set slot loop-number - 1 of {_p}'s current inventory to black stained glass pane named " "

		#
		# > Render all the biomes into the menu, they can be changed in the config.sk
		loop {SB::config::biome::menuitem::*}:
			set {_item} to {SB::config::biome::menuitem::%loop-index%}
			set {_slot} to loop-index parsed as integer
			remove 1 from {_slot}
			set {_price} to {SB::config::biome::price::%loop-index%}
			set {_title} to {SB::config::biome::lang::%{SK::lang::%{_uuid}%}%::%loop-index%}
			set {_biome} to {SB::config::biome::biomename::%loop-index%}
			#
			# > If the price is over 0, set the price in lore to a price
			if {_price} is bigger than 0:
				set {_pricelore} to {SB::lang::bc::shopprice::%{SK::lang::%{_uuid}%}%}
				replace all "<price>" with "%{_price}%" in {_pricelore}
			# > If the price is 0 or lower, tell the player that it is free.
			else:
				set {_pricelore} to {SB::lang::bc::shopfree::%{SK::lang::%{_uuid}%}%}
			setguiitem({_p},{_slot},{_item},1,"&r%{_title}%","&r%{_pricelore}%","buybiomechange(""%{_p}%"" parsed as player,""%{_biome}%"",%{_price}%,""%{_title}%"")",true)
	#
	# > If the player is not the owner, tell the player that this is for the island owner only
	else:
		send "%{SB::lang::prefix::%{SK::lang::%{_uuid}%}%}% %{SB::lang::notleader::%{SK::lang::%{_uuid}%}%}%" to {_p}

# > Function - buybiomechange:
# > Arguments:
# > <player>player
# > Actions:
# > Deducts the money from the player to change a biome, checks if the player
# > has enough money and gives a error if not.
function buybiomechange(p: player, biome:text, price:number, title:text):
	wait 5 ticks
	if balance of {_p} >= {_price}:
		remove {_price} from {_p}'s balance
		changebiome({_p},{_biome},{_title})
	else:
		set {_uuid} to uuid of {_p}
		send "%{SB::lang::prefix::%{SK::lang::%{_uuid}%}%}% %{SB::lang::bc::notenoughmoney::%{SK::lang::%{_uuid}%}%}%" to {_p}


#
# > Function - loadconfig:
# > Actions:
# > This deletes variables to prevent old variables from being in the system
function loadconfig():
	delete {SB::schematics::*}
	delete {SB::calcdown::*}
	delete {SB::oregenc::*}
	delete {SB::oregen::*}
	delete {SB::config::biome::menuitem::*}
	delete {SB::config::biome::biomename::*}
	delete {SB::config::biome::price::*}
	loop {SB::config::biome::biomename::*}:
		delete {SB::config::biome::biomename::%loop-index%::*}
	delete {SB::config::biome::biomename::*}

# > Function - searchbedrock:
# > Arguments:
# > <player>player
# > Actions:
# > Goes trough all possible island locations and check if player's location is within a calculated island and returns the location,
# > if no island matches, the function returns a location with y-coordinate -5 as a error.
function searchbedrock(p:player) :: location:
	#
	# > Here, {_loc} is set to the center of the map, which is always at x0.5, yconfigured height, z0.5 and in a configured world.
	# > This also gets parsed as a world to make it a valid location.
	#
	set {_loc} to location at 0.5, {SB::config::height}, 0.5 in "%{SB::config::world}%" parsed as world
	#
	# > The {_search} variable is for the while loop, once this is deleted or changed, the while loop stops.
	#
	set {_search} to true
	#
	# > The {_s} variable is important to run trough all islands in a organized way.
	# > Since the loop searches for a specific location on a 2D map, it has to find the next point
	# > to check, {_s} tells what should happen next within the while loop.
	#
	set {_s} to 1
	#
	# > The {_l} variable is here to set the amount of times the loop (within the while loop) should
	# > be executed, the {_l} variable is changed within the while loop if the destination was not found.
	#
	set {_l} to 1
	#
	# > The {_distance} variable is set to a local variable and defines the radius of
	# > the island, it is multiplicated by 2 and used to determine the right island size,
	# > distances between islands and protections. Here know which bedrock is nearest
	# > to the specified player.
	#
	set {_distance} to {SB::config::distance}
	#
	# > Start the while loop as long as the local {_search} variable is set to true.
	#
	while {_search} is true:
		#
		# > Counting how many islands are already been searched:
		#
		add 1 to {_i}
		#
		# > If the specified player ({_p} variable) is not online, stop here,
		# > since the location of the specified player is necessary to determine the right bedrock.
		#
		if {_p} is not online:
			delete {_search}
			stop
		#
		# > Loop trough the following code as many times as defined in {_l}. 
		#
		loop {_l} times:
			#
			# > If the {_s} variable is 1 or 5, add the {_distance}*2 to the z- and x-coordinate.
			# > Example, at the beginning, we are at the x like you can view below, then
			# > if {_s} is 1 or 5, we're adding the {_distance}*2 to the z-coordinate.
			# > Every "*" is a island, "x" is the center, where we start, example: server lobby.
			# > Now, if {_s} is 1 or 5, the added {_distance}*2 points to "N", our new island location
			# > which we calculated:
			# > X
			# > ^
			# > | *  *  *  *  *
			# > | *  *  *  *  *
			# > | *  *  x  N  *
			# > | *  *  *  *  *
			# > | *  *  *  *  *
			# > #-------------> Z
			# > (Each "*" is {_distance}*2)
			if {_s} is 1 or 5:
				add ({_distance}*2) to z-coord of {_loc}
			#
			# > If {_s} is 2, we add {_distance}*2 to the x-coordinate, like this:
			# > X
			# > ^
			# > | *  *  *  N  *
			# > | *  *  *  x  *
			# > | *  *  *  *  *
			# > | *  *  *  *  *
			# > | *  *  *  *  *
			# > #-------------> Z
			#
			if {_s} is 2:
				add  ({_distance}*2) to x-coord of {_loc}
			#
			# > If {_s} is 3, we remove {_distance}*2 from the z-coordinate of the location:
			# > X
			# > ^
			# > | *  *  N  x  *
			# > | *  *  *  *  *
			# > | *  *  *  *  *
			# > | *  *  *  *  *
			# > | *  *  *  *  *
			# > #-------------> Z
			#
			if {_s} is 3:
				subtract  ({_distance}*2) from z-coord of {_loc}
			#
			# > If {_s} is 4, we remove {_distance}*2 from the x-coordinate of the location:
			# > X
			# > ^
			# > | *  *  x  *  *
			# > | *  *  N  *  *
			# > | *  *  *  *  *
			# > | *  *  *  *  *
			# > | *  *  *  *  *
			# > #-------------> Z
			#
			if {_s} is 4:
				subtract  ({_distance}*2) from x-coord of {_loc}
			#
			# > With the if statements above, we can control the scan process very easy by changing the
			# > {_s} variable, since this is a while loop, we just change the variable at the end,
			# > and then it gets executed again with the new local {_s} variable.
			#
			
			#
			# > The {_loc} is a new island location, this is where the bedrock of the island.
			# > To be sure that we're not within a protected border or somewhere else, there
			# > is a variable created (array/list), which is set to the location twice.
			# 
			set {_lc::1} to {_loc}
			set {_lc::2} to {_loc}
			#
			# > Here, it is calculated, how big the island actually is, by setting the variables
			# > to point A and B. This is a 3D Model. We take the lowest point on the one corner and
			# > the highest point on the other corner to check, if the player is within this selected area.
			#
			add ({_distance} - {SB::config::protect}) to x-coord of {_lc::1}
			add ({_distance} - {SB::config::protect}) to z-coord of {_lc::1}
			subtract ({_distance} - {SB::config::protect}) from x-coord of {_lc::2}
			subtract ({_distance} - {SB::config::protect}) from z-coord of {_lc::2}
			set y-coord of {_lc::1} to 256
			set y-coord of {_lc::2} to 0
			#
			# > If the player is actually in this space, we return the location of the bedrock and
			# > delete the {_search} variable to stop the while loop from doing more loops.
			#
			if location of {_p} is within {_lc::1} to {_lc::2}:
				return {_loc}
				delete {_search}
		#
		# > We're here if we couldn't find the right island we wanted, now we try to find it
		# > by changing the {_s} variable and looping through this code above again,
		# > we can go trough all islands until we have it found.
		# > Now lets visualise to make it easier to understand what this is actually doing:
		#
		# > If {_s} is 6, it is changed back to 2, this does the following in the next loop cycle:
		# > (x is the old island, N the new island location)
		# > X
		# > ^
		# > | *  *  *  N  *
		# > | *  *  *  x  *
		# > | *  *  *  *  *
		# > | *  *  *  *  *
		# > | *  *  *  *  *
		# > #-------------> Z
		#
		if {_s} is 6:
			set {_s} to 2
		#
		# > If {_s} is not 6, add 1 to {_s} and go forward, if it is 4 after 1 was added, it does the following:
		# > (x is the old island, N the new island location)
		# > X
		# > ^
		# > | *  *  x  *  *
		# > | *  *  N  *  *
		# > | *  *  *  *  *
		# > | *  *  *  *  *
		# > | *  *  *  *  *
		# > #-------------> Z
		#
		else:
			add 1 to {_s}
		#
		# > If {_s} is either 3 or 5, add 1 to {_l} to loop once more.
		# > The loop within the while loop is going to looped one more time to go one step further.
		if {_s} is 3 or 5:
			add 1 to {_l}
		#
		# > To make this whole process more visible how it would look in action, i made the same like above
		# > and visualised it with integers. 1 = first, 9 = last island of this example being calculated.
		# > (x is the lobby at X=0,Z=0)
		# > X
		# > ^
		# > | *  *  *  *  *
		# > | *  4  3  2  *
		# > | *  5  x  1  *
		# > | *  6  7  8  9
		# > | *  *  *  *  *
		# > #-------------> Z
		#
		# > If we're seaching already for more islands than there are, stop it and return a error.
		#
		if {_i} is bigger than size of {SB::islvl::*}:
			#
			# > Delete {_search} to stop the while loop.
			#
			delete {_search}
			#
			# > Set a new location with a y-coordinate of -5, which is a error. The return has
			# > to be a location, that is why we're not returning false.
			#
			set {_loc} to location at 5, -5, 5 in "%{SB::config::world}%" parsed as world
			return {_loc}

#
# > Import of all necessary classes for the loadislandstoworld function
#
import:
	java.io.File
	java.io.FileInputStream
	java.io.FileOutputStream

# > Function - loadislandstoworld:
# > Arguments:
# > none
# > Actions:
# > Once the configuration file is loaded, this function is executed.
# > This function loads ".nbt" files from the "plugins/Skript/scripts/SkyBlock/islands" folder
# > into the defined world folder.
function loadislandstoworld():
	#
	# > Get a list all files in the folder of the "plugins/Skript/scripts/SkyBlock/islands" folder
	#
	set {_files::*} to ...new File("plugins/Skript/scripts/SkyBlock/islands").listFiles()
	#
	# > Loop trough all the files
	#
	loop {_files::*}:
		#
		# > If the loop-value (file) ends with ".nbt", it should continue
		#
		set {_check} to loop-value.toString().endsWith(".nbt")
		if {_check} is true:
			#
			# > Prints to console that it tries to copy import the files.
			#
			send "[SkyBlock] > Try to import %{_fname}% into your world..." to console
			#
			# > Get the name of the loop file.
			#
			set {_fname} to loop-value.getName()
			#
			# > Look if there is already a file with that name
			#
			set {_checkfile} to new File("%{SB::config::world}%/generated/minecraft/structures/%{_fname}%")
			if {_checkfile}.isFile() is true:
				#
				# > Print that there is already a file with this name
				#
				send "[SkyBlock] > %{_fname}% is already set." to console
			else:
				#
				# > There is no file with that name, copy it.
				# > Set the {_source} to the loop file (our source)
				#
				set {_source} to loop-value
				#
				# > Set the {_dest} to our destination, which we already used with {_checckfile} above
				#
				set {_dest} to {_checkfile}
				#
				# > Set both stream channels to null
				#
				set {_sourceChannel} to null
				set {_destChannel} to null
				#
				# > Open a new input and output stream to copy the files using transferFrom
				#
				set {_sourceChannel} to new FileInputStream({_source}).getChannel()
				set {_destChannel} to new FileOutputStream({_dest}).getChannel()
				#
				# > Copy the file from the {_sourceChannel} to the {_destChannel}
				#
				{_destChannel}.transferFrom({_sourceChannel}, 0, {_sourceChannel}.size())
				#
				# > Close both streams and print a success message to console
				#
				{_sourceChannel}.close()
				{_destChannel}.close()
				send "[SkyBlock] > Successfully imported %{_fname}%!" to console
