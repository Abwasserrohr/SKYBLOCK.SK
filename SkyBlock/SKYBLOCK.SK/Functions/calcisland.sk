#
# ==============
# calcisland.sk
# ==============
# calcisland.sk is part of the SKYBLOCK.SK functions.
# ==============

#
# > Function: calcisland
# > Arguments:
# > <offline player>player
# > Actions:
# > Calculates the island level by getting both borders on the island, then looping though all blocks and
# > calculating all predefined experience bonuses from the configuration together to get a level.
function calcisland(p:offline player):
  set {_exp} to 0 
  set {_level} to 1
  #
  # > Set the experience needed for the next level:
  set {_xpn} to {_level}*{SB::config::explevel}
  #
  # > Get the uuid of the player
  set {_uuid} to uuid of {_p}
  #
  # > Get the location of the bedrock of the island the player is on:
  set {_bedrock} to block at {SB::player::%{_uuid}%::island::bedrock}
  #
  # > Set a local variable for chest and storage unit calculation.
  set {_calculatechest} to yaml value "calcinventory" from "plugins/Skript/scripts/SkyBlock/config/blocks.yml"
  set {_calculatestorage} to yaml value "calcstorage" from "plugins/Skript/scripts/SkyBlock/config/blocks.yml"
  #
  # > Prevent chunks from unloading.
  set metadata value "nochunkunload" of getdummy() to true
  set {_exp} to 0
  #
  # > Calculate, how many blocks have be checked to make a fully working progress bar:
  set {_l} to {SB::config::distance}*2
  set {_b} to {SB::config::distance}*2
  set {_h} to 256
  set {_size} to {_l}*{_b}*{_h}
  #
  # > Get the border locations of the island to calculate the island level.
  set {_dist} to {SB::config::distance}
  set {_b1} to location of {_bedrock}
  set {_b2} to location of {_bedrock}
  add ({_dist} - {SB::config::protect}) to x-coord of {_b1}
  add ({_dist} - {SB::config::protect}) to z-coord of {_b1}
  subtract ({_dist} - {SB::config::protect}) from x-coord of {_b2}
  subtract ({_dist} - {SB::config::protect}) from z-coord of {_b2}
  #
  # > The first loop only loops the y-coordinate 0.
  set y-coordinate of {_b2} to 0
  set y-coordinate of {_b1} to 0
  #
  # > Set the experience per block into a list and convert it to a usable format for us.
  set {_bxp::*} to yaml list "blocks" from "plugins/Skript/scripts/SkyBlock/config/blocks.yml"
  loop {_bxp::*}:
    set {_lv} to "%loop-value%"
    replace all "{" with "" in {_lv}
    replace all "}" with "" in {_lv}
    set {_lv::*} to {_lv} split at "="
    set {_blockexp::%{_lv::1}%} to {_lv::2} parsed as number
  #
  # > If the nether is enabled, double the island size, since we have the normal island and the nether island.
  if {SB::config::nether} is true:
    set {_size} to {_size}*2
    set {_loops} to 2
  else:
    set {_loops} to 1
  set {_needed} to 0
  set {_progress} to "%{SB::config::color::background::1}%||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||&r"
  #
  # > If the nether islands are enabled, this function has to loop two times through the two islands (normal and nether).
  loop {_loops} times:
    add 1 to {_looptime}
    if {_looptime} is 2:
      set {_b1} to location at x-coord of {_b1}, y-coord of {_b1}, z-coord of {_b1} in "%{SB::config::netherworld}%" parsed as world
      set {_b2} to location at x-coord of {_b2}, y-coord of {_b2}, z-coord of {_b2} in "%{SB::config::netherworld}%" parsed as world
    #
    # > If there are robots active, check if there are any within,
    # > the island and disable them to calculate properly.
    set {_robotsize} to size of {TMP::activerobo::*}
    if {_robotsize} >= 1:
      loop {TMP::activerobo::*}:
        if loop-value-2's location is within {_b1} to {_b2}:
          disablerobot(loop-value-2)
    #
    # > Loop all blocks within the two borders:
    loadtempchunks({_b1},{_b2})
    loop blocks within {_b1} to {_b2}:
      set {_loc} to location of loop-block
      set {_loc1} to location of loop-block
      set y-coord of {_loc1} to 256
      #
      # > Load the blocks within the x- and z-coord, from y-coord 0 to 256.
      loop blocks within {_loc} to {_loc1}:
        if loop-block-2.isEmpty() is false:
          set {_tb} to "%loop-block-2.getType()%"
          if loop-block-2 is a hopper:
            add 1 to {_hopper}
          #
          # > If the looped block as a inventory, check if it is a
          # > storage unit or a normal inventory block.
          if loop-block-2's inventory is set:
            set {_storage} to false
            #
            # > If the slot 26 of the inventory is clay and has "STORAGE" on the
            # > 2nd line of the clay item, it is a storage unit.
            if slot 26 of loop-block-2's inventory is clay:
              if line 2 of lore of slot 26 of loop-block-2's inventory is "STORAGE":
                set {_storage} to true
                #
                # > If storage calculation is enabled, add the contents experience
                # > values to the island experience.
                if {_calculatestorage} is true:
                  set {_itemdata} to slot 26 of loop-block-2's inventory
                  set {_savedamount} to line 1 of lore of {_itemdata} parsed as number
                  set {_storeditem} to slot 0 of loop-block-2's inventory
                  set {_tbi} to "%{_storeditem}.getType()%"
                  set {_add} to {_blockexp::%{_tbi}%} * {_savedamount}
                  add {_add} to {_exp}
            #
            # > If it isn't a storage unit and chest calculation is enabled,
            # > loop through the inventory and add the experience values of the
            # > items to the island experience.
            if {_storage} is false:
              if {_calculatechest} is true:
                loop all items in loop-block-2's inventory:
                  set {_item} to loop-item
                  set {_tbi} to "%{_item}.getType()%"
                  if {_blockexp::%{_tbi}%} is set:
                    set {_add} to {_blockexp::%{_tbi}%} * "%{_item}.getAmount()%" parsed as number
                    add {_add} to {_exp}
          #
          # > If there is experience set for this block, add it to the island experience.
          if {_blockexp::%{_tb}%} is set:
            #
            # > Add the experience of the block to the local experience variable {_exp}
            add {_blockexp::%{_tb}%} to {_exp}
      add 256 to {_i}
      add 256 to {_blocks}
      #
      # > Update the status every 50000 blocks.
      if {_i} > 50000:
        set {_percent} to ({_blocks}/{_size})*100
        #
        # > If the percentage is bigger than the one before, replace one of the | progress bars with a colored one.
        if {_percent} >= {_needed}:
          add 1 to {_needed}
          replace all "%{SB::config::color::background::1}%|" with "%{SB::config::color::primary::1}%|%{SB::config::color::background::1}%" in {_progress}
        #
        # > Send the current progress bar to the player.
        if {_blocks} > {_size}:
          set {_blocks} to {_size}
        actionbar({_p},"%{_progress}% %{SB::config::color::background::1}%[%{_blocks}%%{SB::config::color::primary::1}%/%{SB::config::color::background::1}%%{_size}%]")
        #
        # > Set the counter back to 0 to do this again in 5000 blocks.
        set {_i} to 0
  #
  # > Calculate the island level using a while loop.
  while {_endfound} is not set:
    if {_exp} is more than {_xpn}:
      add 1 to {_level}
      set {_xpn} to ({_level} * {SB::config::explevel})
    else:
      set {_endfound} to true
  delete {_endfound}
  #
  # > Save the generated level to the island variable.
  set {_x} to x-coord of {_bedrock}
  set {_y} to y-coord of {_bedrock}
  set {_z} to z-coord of {_bedrock}
  set {SB::island::%{_x}%_%{_y}%_%{_z}%::level} to {_level}
  #
  # > Delete the block list again to clear it out from the ram.
  delete {_bxp::*}
  #
  # > Set level to a list of all island levels.
  set {SB::islvl::%{_x}%_%{_y}%_%{_z}%} to {_level}
  #
  # > Updates the hopper count to the new counted amount of hoppers:
  set {_tmp} to hoppercounter({_p},"update",{_hopper})
  #
  # > Print the new level to the player trough the actionbar.
  wait 5 ticks
  actionload({_p},"&rLevel: &6&l%{_level}%")
  delete {SB::calcstatus::%{_p}%}
  delete metadata value "nochunkunload" of getdummy()

#
# > Event - on chunk unload
# > Actions:
# > If the value "nochunkunload" of the metadata of a dummy block is
# > true, no chunks can unload. This is needed to prevent fast
# > loading and unloading of chunks while calculating the island.
on chunk unload:
  if metadata value "nochunkunload" of getdummy() is true:
    cancel event

#
# > Function - loadtempchunks
# > Parameters:
# > <location>location 1
# > <loaction>location 2
# > Actions:
# > Loops through all blocks between the two location and loads the chunks,
# > with chunk unload prevention, these chunks keep being loaded for a fast
# > island calculation.
function loadtempchunks(l1:location,l2:location):
  wait 1 tick
  loop blocks within {_l1} to {_l2}:
    set {_chunk} to chunk at loop-block
  delete {_chunk}
