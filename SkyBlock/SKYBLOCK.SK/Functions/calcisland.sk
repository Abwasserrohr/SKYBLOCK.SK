#
# ==============
# calcisland.sk
# ==============
# calcisland.sk is part of the SKYBLOCK.SK functions.
# ==============

#
# > Function: calcisland
# > Arguments:
# > <offline player>player
# > Actions:
# > Calculates the island level by getting both borders on the island, then looping though all blocks and
# > calculating all predefined experience bonuses from the configuration together to get a level.
function calcisland(p:offline player):
  set {_exp} to 0 
  set {_level} to 1
  #
  # > Set the experience needed for the next level:
  set {_xpn} to {_level}*{SB::config::explevel}
  #
  # > Get the uuid of the player
  set {_uuid} to uuid of {_p}
  #
  # > Get the location of the bedrock of the island the player is on:
  set {_bedrock} to block at {SB::player::%{_uuid}%::island::bedrock}
  #
  # > Set a local variable for chest and storage unit calculation.
  set {_calculatechest} to yaml value "calcinventory" from "plugins/Skript/scripts/SkyBlock/config/blocks.yml"
  set {_calculatestorage} to yaml value "calcstorage" from "plugins/Skript/scripts/SkyBlock/config/blocks.yml"
  set {_exp} to 0
  #
  # > Calculate, how many blocks have be checked to make a fully working progress bar:
  set {_dist} to {SB::config::distance}
  set {_l} to {_dist}*2
  set {_b} to {_dist}*2
  set {_h} to 256
  set {_size} to {_l}*{_b}*{_h}
  #
  # > Get the border locations of the island to calculate the island level.
  set {_b1} to location of {_bedrock}
  set {_b2} to location of {_bedrock}
  add ({_dist} - {SB::config::protect}) to x-coord of {_b1}
  add ({_dist} - {SB::config::protect}) to z-coord of {_b1}
  subtract ({_dist} - {SB::config::protect}) from x-coord of {_b2}
  subtract ({_dist} - {SB::config::protect}) from z-coord of {_b2}
  #
  # > The first loop only loops the y-coordinate 0.
  set y-coordinate of {_b2} to 0
  set y-coordinate of {_b1} to 0
  #
  # > Set the experience per block into a list and convert it to a usable format for us.
  set {_bxp::*} to yaml list "blocks" from "plugins/Skript/scripts/SkyBlock/config/blocks.yml"
  loop {_bxp::*}:
    set {_lv} to "%loop-value%"
    replace all "{" with "" in {_lv}
    replace all "}" with "" in {_lv}
    set {_lv::*} to {_lv} split at "="
    set {_blockexp::%{_lv::1}%} to {_lv::2} parsed as number
  #
  # > If the nether is enabled, double the island size, since we have the normal island and the nether island.
  if {SB::config::nether} is true:
    set {_size} to {_size}*2
    set {_loops} to 2
  else:
    set {_loops} to 1
  set {_needed} to 0
  set {_progress} to "%{SB::config::color::secondary::1}%||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||&r"
  #
  # > If the nether islands are enabled, this function has to loop two times through the two islands (normal and nether).
  loop {_loops} times:
    add 1 to {_looptime}
    if {_looptime} is 2:
      set {_b1} to location at x-coord of {_b1}, y-coord of {_b1}, z-coord of {_b1} in "%{SB::config::netherworld}%" parsed as world
      set {_b2} to location at x-coord of {_b2}, y-coord of {_b2}, z-coord of {_b2} in "%{SB::config::netherworld}%" parsed as world
    #
    # > If there are robots active, check if there are any within,
    # > the island and disable them to calculate properly.
    set {_robotsize} to size of {TMP::activerobo::*}
    if {_robotsize} >= 1:
      loop {TMP::activerobo::*}:
        if isWithinArea(loop-value-2's location,{_b1},{_b2}) is true:
          disablerobot(loop-value-2)
    #
    # > Force load all needed chunks for a faster calculation process.
    handletempchunks({_p},true)
	#
	# > Get the minimum and maximum coordinate for each x-, y- and z-coord.
    set {_x1} to getmin(x-coord of block at {_b1}, x-coord of block at {_b2})
    set {_x2} to getmax(x-coord of block at {_b1}, x-coord of block at {_b2})
    set {_y1} to getmin(y-coord of block at {_b1}, y-coord of block at {_b2})
    set {_y2} to getmax(y-coord of block at {_b1}, y-coord of block at {_b2})
    set {_z1} to getmin(z-coord of block at {_b1}, z-coord of block at {_b2})
    set {_z2} to getmax(z-coord of block at {_b1}, z-coord of block at {_b2})
    #
    # > Loop through the island by going through every x- and z-coord and then
    # > looping the y-coordinate trough.
    set {_x} to {_x1}
    while {_x} < {_x2}:
      add 1 to {_x}
      set {_z} to {_z1}
      while {_z} < {_z2}:
        add 1 to {_z}
        add 1 to {_i}
        set {_l1} to location at {_x}, 256, {_z} in "%{_b1}'s world%" parsed as world
        set {_l2} to {_l1}
        set y-coord of {_l2} to 0
        loop all blocks from block at {_l1} to block at {_l2}:
          if loop-block.isEmpty() is false:
            set {_tb} to "%loop-block.getType()%"
            if loop-block is a hopper:
              add 1 to {_hopper}
            #
            # > If the looped block as a inventory, check if it is a
            # > storage unit or a normal inventory block.
            if loop-block's inventory is set:
              set {_storage} to false
              #
              # > If the slot 26 of the inventory is clay and has "STORAGE" on the
              # > 2nd line of the clay item, it is a storage unit.
              if slot 26 of loop-block's inventory is clay:
                if line 2 of lore of slot 26 of loop-block's inventory is "STORAGE":
                  set {_storage} to true
                  #
                  # > If storage calculation is enabled, add the contents experience
                  # > values to the island experience.
                  if {_calculatestorage} is true:
                    set {_itemdata} to slot 26 of loop-block's inventory
                    set {_savedamount} to line 1 of lore of {_itemdata} parsed as number
                    set {_storeditem} to slot 0 of loop-block's inventory
                    set {_tbi} to "%{_storeditem}.getType()%"
                    set {_add} to {_blockexp::%{_tbi}%} * {_savedamount}
                    add {_add} to {_exp}
              #
              # > If it isn't a storage unit and chest calculation is enabled,
              # > loop through the inventory and add the experience values of the
              # > items to the island experience.
              if {_storage} is false:
                if {_calculatechest} is true:
                  loop all items in loop-block's inventory:
                    set {_item} to loop-item
                    set {_tbi} to "%{_item}.getType()%"
                    if {_blockexp::%{_tbi}%} is set:
                      set {_add} to {_blockexp::%{_tbi}%} * "%{_item}.getAmount()%" parsed as number
                      add {_add} to {_exp}
            #
            # > If there is experience set for this block, add it to the island experience.
            if {_blockexp::%{_tb}%} is set:
              #
              # > Add the experience of the block to the local experience variable {_exp}
              add {_blockexp::%{_tb}%} to {_exp}
        add 256 to {_i}
        add 256 to {_blocks}
        #
        # > Update the status every 50000 blocks.
        if {_i} > 50000:
          set {_percent} to ({_blocks}/{_size})*100
          #
          # > If the percentage is bigger than the one before, replace one of the | progress bars with a colored one.
          if {_percent} >= {_needed}:
            add 1 to {_needed}
            replace all "%{SB::config::color::secondary::1}%|" with "%{SB::config::color::primary::1}%|%{SB::config::color::secondary::1}%" in {_progress}
          #
          # > Send the current progress bar to the player.
          if {_blocks} > {_size}:
            set {_blocks} to {_size}
          actionbar({_p},"%{_progress}% %{SB::config::color::secondary::1}%[%{_blocks}%%{SB::config::color::primary::1}%/%{SB::config::color::secondary::1}%%{_size}%]")
          #
          # > Set the counter back to 0 to do this again in 5000 blocks.
          set {_i} to 0

  #
  # > Calculate the island level using a while loop.
  while {_endfound} is not set:
    if {_exp} is more than {_xpn}:
      add 1 to {_level}
      set {_xpn} to ({_level} * {SB::config::explevel})
    else:
      set {_endfound} to true
  delete {_endfound}
  #
  # > Save the generated level to the island variable.
  set {_x} to x-coord of {_bedrock}
  set {_y} to y-coord of {_bedrock}
  set {_z} to z-coord of {_bedrock}
  set {SB::island::%{_x}%_%{_y}%_%{_z}%::level} to {_level}
  #
  # > Delete the block list again to clear it out from the ram.
  delete {_bxp::*}
  #
  # > Set level to a list of all island levels.
  set {SB::islvl::%{_x}%_%{_y}%_%{_z}%} to {_level}
  #
  # > Updates the hopper count to the new counted amount of hoppers:
  set {_tmp} to hoppercounter({_p},"update",{_hopper})
  #
  # > Print the new level to the player trough the actionbar.
  wait 5 ticks
  actionload({_p},"&rLevel: &6&l%{_level}%")
  delete {SB::calcstatus::%{_p}%}
  #
  # > Unload all force loaded chunks of that player.
  handletempchunks({_p},false)

#
# > Function - handletempchunks
# > Parameters:
# > <offline player> the player which island should be calculated.
# > <boolean>force load temp chunks=true,remove force load temp chunks=false
# > Actions:
# > Loops through all blocks between the two location and loads the chunks,
# > with chunk unload prevention, these chunks keep being loaded for a fast
# > island calculation.
function handletempchunks(p:offline player,load:boolean=true):
  #
  # > Wait a tick, that way, threaded functions do not have to wait
  # > but can work async.
  wait 1 tick

  #
  # > Calculate the borders which should be calculated.
  set {_b1} to location of {_bedrock}
  set {_b2} to location of {_bedrock}
  add ({_dist} - {SB::config::protect}) to x-coord of {_b1}
  add ({_dist} - {SB::config::protect}) to z-coord of {_b1}
  subtract ({_dist} - {SB::config::protect}) from x-coord of {_b2}
  subtract ({_dist} - {SB::config::protect}) from z-coord of {_b2}

  #
  # > Get the minimum and maximum of each x-,y- and z-coord.
  set {_x1} to getmin(x-coord of block at {_b1}, x-coord of block at {_b2})
  set {_x2} to getmax(x-coord of block at {_b1}, x-coord of block at {_b2})
  set {_z1} to getmin(z-coord of block at {_b1}, z-coord of block at {_b2})
  set {_z2} to getmax(z-coord of block at {_b1}, z-coord of block at {_b2})

  set {_world} to "%{_b1}'s world%" parsed as world

  #
  # > Loop through the whole island and load the chunks and set them force loaded
  # > to prevent them from being unloaded.
  set {_x} to {_x1}
  while {_x} < {_x2}:
    add 1 to {_x}
    set {_z} to {_z1}
    while {_z} < {_z2}:
      add 1 to {_z}
      set {_l1} to location at {_x}, 1, {_z} in {_world}
      set {_chunk} to chunk at block at {_l1}
      broadcast "%{_chunk}%"

      #
      # > Only load the chunk if it should be loaded.
      if {_load} is true:
        {_chunk}.load()

      #
      # > Change the force loaded status depending on the parameter.
      {_chunk}.setForceLoaded({_load})
  delete {_chunk}
