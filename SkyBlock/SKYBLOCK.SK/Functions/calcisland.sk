#
# ==============
# calcisland.sk
# ==============
# calcisland.sk is part of the SKYBLOCK.SK functions.
# ==============

#
# > Function: calcisland
# > Arguments:
# > <player>player
# > Actions:
# > Calculates the island level by getting both borders on the island, then looping though all blocks and
# > calculating all predefined experience bonuses from the configuration together to get a level.
function calcisland(p:offline player):
  set {_exp} to 0 
  set {_level} to 1
  #
  # > Set the experience needed for the next level:
  set {_xpn} to {_level}*{SB::config::explevel}
  #
  # > Get the uuid of the player
  set {_uuid} to uuid of {_p}
  #
  # > Get the location of the bedrock of the island the player is on:
  set {_bedrock} to {SB::player::%{_uuid}%::island::bedrock}
  #
  # > Get the border locations of the island to calculate the island level.
  set {_dist} to {SB::config::distance}
  set {_b1} to location of {_bedrock}
  set {_b2} to location of {_bedrock}
  add ({_dist} - {SB::config::protect}) to x-coord of {_b1}
  add ({_dist} - {SB::config::protect}) to z-coord of {_b1}
  subtract ({_dist} - {SB::config::protect}) from x-coord of {_b2}
  subtract ({_dist} - {SB::config::protect}) from z-coord of {_b2}
  set y-coordinate of {_b2} to 256
  set y-coordinate of {_b1} to 0
  #
  # > Calculate, how many blocks have be checked to make a fully working progress bar:
  set {_l} to {SB::config::distance}*2
  set {_b} to {SB::config::distance}*2
  set {_h} to 256
  set {_size} to {_l}*{_b}*{_h}
  #
  # > If the nether is enabled, double the island size, since we have the normal island and the nether island.
  if {SB::config::nether} is true:
    set {_size} to {_size}*2
    set {_loops} to 2
  else:
    set {_loops} to 1
  set {_needed} to 0
  set {_progress} to "%{SB::config::color::secondary::2}%||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||&r"
  #
  # > If the nether islands are enabled, this function has to loop two times through the two islands (normal and nether).
  loop {_loops} times:
    add 1 to {_looptime}
    if {_looptime} is 2:
      set {_b1} to location at x-coord of {_b1}, y-coord of {_b1}, z-coord of {_b1} in "%{SB::config::netherworld}%" parsed as world
      set {_b2} to location at x-coord of {_b2}, y-coord of {_b2}, z-coord of {_b2} in "%{SB::config::netherworld}%" parsed as world
    #
	# > Loop all blocks within the two borders:
    loop blocks within {_b1} to {_b2}:
      add 1 to {_i}
      #
      # > Setting the chunk of the current loop block to a local variable to load the chunk
      #set {_lb} to chunk at loop-block
      #
      # > Every 10000 blocks, check for new percentages for the progress bar.
      if {_i} is 10000:
        add 10000 to {_b}
        wait 1 tick
        set {_percent} to ({_b}/{_size})*100
        #
        # > If the percentage is bigger than the one before, replace one of the | progress bars with a colored one.
        if {_percent} >= {_needed}:
          add 1 to {_needed}
          replace all "%{SB::config::color::secondary::2}%|" with "%{SB::config::color::primary::1}%|%{SB::config::color::secondary::2}%" in {_progress}
        #
        # > Send the current progress bar to the player.
        actionbar({_p},"%{_progress}% %{SB::config::color::secondary::2}%[%{_b}%%{SB::config::color::primary::1}%/%{SB::config::color::secondary::2}%%{_size}%]")
        #
        # > Set the counter back to 0 to do this again in 10000 blocks.
        set {_i} to 0
      #
      # > Count blocks that aren't air and check them.
      if loop-block.isEmpty() is false:
        set {_tb} to loop-block.getType()
        if loop-block is a hopper:
          add 1 to {_hopper}
        if {SB::expblocks::%{_tb}%} is set:
          #
          # > Add the experience of the block to the local experience variable {_exp}
          add {SB::expblocks::%{_tb}%} to {_exp}
          #
          # > If the experience variable {_exp} is higher than the "needed experience" variable {_xpn}, add one level
          # > and increase the difficulty to reach the next level.
          if {_exp} is more than {_xpn}:
            add 1 to {_level}
            set {_xpn} to ({_level} * {SB::config::explevel})
        else:
          #
          # > If debug is set, tell everyone that the current material has no value for calculation.
          if {SB::config::debug} is true:
            broadcast "[Debug] %{_tb}% has no value for /island calc"
          add {SB::expblocks::other} to {_exp}
          #
          # > If the experience variable {_exp} is higher than the "needed experience" variable {_xpn}, add one level
          # > and increase the difficulty to reach the next level.
          if {_exp} is more than {_xpn}:
            add 1 to {_level}
            set {_xpn} to ({_level} * {SB::config::explevel})
  #
  # > Save the generated level to the island variable.
  set {_x} to x-coord of {_bedrock}
  set {_y} to y-coord of {_bedrock}
  set {_z} to z-coord of {_bedrock}
  set {SB::island::%{_x}%_%{_y}%_%{_z}%::level} to {_level}
  #
  # > Set level to a list of all island levels.
  set {SB::islvl::%{_x}%_%{_y}%_%{_z}%} to {_level}

  #
  # > Updates the hopper count to the new counted amount of hoppers:
  set {_tmp} to hoppercounter({_p},"update",{_hopper})
  #
  # > Print the new level to the player trough the actionbar.
  wait 5 ticks
  actionload({_p},"&rLevel: &6&l%{_level}%")
  delete {SB::calcstatus::%{_p}%}
