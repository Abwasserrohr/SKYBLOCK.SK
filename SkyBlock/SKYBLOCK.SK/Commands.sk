#
# > Command - /islandadmin 
# > Actions:
# > This command contains multible of actions which are meant to be used by an administrator for
# > administration and moderation purposes.
command /islandadmin [<text>] [<text>] [<text>] [<text>] [<text>]:
	permission:	is.admin
	aliases: /isadmin
	trigger:
		#
		# > Set prefix for messages
		set {_prefix} to {SB::lang::prefix::%{SK::lang::%uuid of player%}%}
		#
		# > Argument: "go" ("home" OR "tp")
		# > Teleports the user to the defined player
		# > Actions:
		# > Teleports the player to the defined player island
		if arg-1 is "go" OR "home" OR "tp":
			set {_player} to arg-2 parsed as offline player
			set {_uuid} to uuid of {_player}
			set {_bedrock} to {SB::player::%{_uuid}%::island::bedrock}
			set {_x} to x-coord of {_bedrock}
			set {_y} to y-coord of {_bedrock}
			set {_z} to z-coord of {_bedrock}
			if {SB::island::%{_x}%_%{_y}%_%{_z}%::home::home} is set:
				teleport player to {SB::island::%{_x}%_%{_y}%_%{_z}%::home::home}
			stop
		#
		# > If something should be done with an island, this is the code:
		else if arg-1 is "island":
			#
			# > Argument: "calc"
			# > If the user types in /islandadmin island calc, the island level gets calculated
			# > Actions:
			# > Checks if the defined user has a island and then run the calcisland function.
			if arg-2 is "calc":
				set {_player} to arg-3 parsed as offline player
				set {_uuid} to uuid of {_player}
				if {SB::player::%{_uuid}%::island::leader} is set:
					message "%{_prefix}% %{SB::lang::isadmin::fcalc::%{SK::lang::%uuid of player%}%}%"
					set {_player} to arg-3 parsed as offline player
					$ thread
					calcisland({_player})

			#
			# > Argument: "purge"
			# > If the user types in /islandadmin island purge <number>, islands, which have been inactive for the defined
			# > number of days are going to be deleted. This is dangerous and a backup should be made prior entering this.
			# > Actions:
			# > Deleted all islands which have been inactive for more than x days.
			if arg-2 is "purge":
				if arg-3 is not set:
					stop
				set {_days} to "%arg-3% days" parsed as timespan
				loop {SB::islvl::*}:
					if {SB::island::%loop-index%::lastactive} is not set:
						set {SB::island::%loop-index%::lastactive} to now
					if {SB::island::%loop-index%::created} is not set:
						set {SB::island::%loop-index%::created} to now
					if difference between {SB::island::%loop-index%::lastactive} and now is bigger than {_days}:
						add loop-index to {_delislands::*}
				if arg-4 is "purgeok":
					loop {_delislands::*}:
						deleteisland({SB::island::%loop-index%::leader})
					set {_a} to {SB::lang::isadmin::deletedxis::%{SK::lang::%uuid of player%}%}
					replace all "<amount>" with "%size of {_delislands::*}%" in {_a}
					message "%{_prefix}% %{_a}%"
					message "%{_prefix}% %{SB::lang::isadmin::isremovedonrestart::%{SK::lang::%uuid of player%}%}%"
					stop
				#
				# > Create a tellraw to ask if the user really wants to purge the islands
				set {_a} to {SB::lang::isadmin::xwouldbedeleted::%{SK::lang::%uuid of player%}%}
				replace all "<amount>" with "%size of {_delislands::*}%" in {_a}
				message "%{_prefix}% %{_a}%"
				set {_a} to {SB::lang::isadmin::areyousuretodelete::%{SK::lang::%uuid of player%}%}
				replace all "<amount>" with "%size of {_delislands::*}%" in {_a}
				set {_prefix} to "%{_prefix}% %{_a}%"
				set {_msg} to "%{SB::lang::isadmin::yes::%{SK::lang::%uuid of player%}%}%"
				tellrawmsg1(player,{_prefix},{_msg},"/islandadmin island purge %arg-3% purgeok")
			if arg-2 is "delete":
				if arg-4 is "deleteok":
					set {_player} to arg-3 parsed as offline player
					#
					# > Deletes the island
					deleteisland({_player})
					#
					# > Prints a success message
					set {_a} to {SB::lang::isadmin::islandofdeleted::%{SK::lang::%uuid of player%}%}
					replace all "<player>" with "%{_player}%" in {_a}
					message "%{_prefix}% %{_a}%"
				set {_bedrock} to searchbedrock(player)
				if y-coordinate of {_bedrock} is -5:
					#
					# > Prints the defined spacers and a message that the island could not be found:
					#
					message "%{SB::config::spacer}%"
					message "%{_prefix}% %{SB::lang::isinfonotfound::%{SK::lang::%uuid of player%}%}%"
					message "%{SB::config::spacer}%"
					stop
				else:
					set {_loc::1} to x-coord of {_bedrock}
					set {_loc::2} to y-coord of {_bedrock}
					set {_loc::3} to z-coord of {_bedrock}
					#
					# > If there is a leader set to this island, create a promt if it should be really deleted
					if {SB::island::%{_loc::1}%_%{_loc::2}%_%{_loc::3}%::leader} is set:
						set {_a} to {SB::lang::isadmin::suretodeleteisofp::%{SK::lang::%uuid of player%}%}
						replace all "<player>" with "%{_player}%" in {_a}
						set {_prefix} to "%{_prefix}% %{_a}%"
						set {_msg} to "%{SB::lang::isadmin::yes::%{SK::lang::%uuid of player%}%}%"
						tellrawmsg1(player,{_prefix},{_msg},"/islandadmin island delete %{SB::island::%{_loc::1}%_%{_loc::2}%_%{_loc::3}%::leader} parsed as offline player% deleteok")

			#
			# > Argument: "addmember"
			# > If the user types in /islandadmin island addmember <player>, the defined player is added to the island.
			# > Actions:
			# > Adds the player to the island the executor is standing on.
			if arg-2 is "addmember":
				set {_player} to arg-3 parsed as offline player
				set {_uuid} to uuid of {_player}
				set {_bedrock} to {SB::player::%{_uuid}%::island::bedrock}
				if {_bedrock} is set:
					set {_a} to {SB::lang::alreadyotheris::%{SK::lang::%uuid of player%}%}
					replace all "<player>" with "%{_player}%" in {_a}
					message "%{_prefix}% %{_a}%"
					stop
				
				set {_bedrock} to searchbedrock(player)
				if y-coordinate of {_bedrock} is -5:
					#
					# > Prints the defined spacers and a message that the island could not be found:
					#
					message "%{SB::config::spacer}%"
					message "%{_prefix}% %{SB::lang::isinfonotfound::%{SK::lang::%uuid of player%}%}%"
					message "%{SB::config::spacer}%"
					stop
				else:

					set {_loc::1} to x-coord of {_bedrock}
					set {_loc::2} to y-coord of {_bedrock}
					set {_loc::3} to z-coord of {_bedrock}
					
					if {SB::island::%{_loc::1}%_%{_loc::2}%_%{_loc::3}%::leader} is "---":
						set {SB::player::%{_uuid}%::island::leader} to {_uuid}
						set {SB::island::%{_loc::1}%_%{_loc::2}%_%{_loc::3}%::leader} to {_uuid}
					else:
						add uuid of player to {SB::island::%{_loc::1}%_%{_loc::2}%_%{_loc::3}%::member::*}

					#
					# > Sets everything needed to have a working island
					set {SB::player::%{_uuid}%::island::bedrock} to {_bedrock}
					set {SB::player::%{_uuid}%::island::leader} to {SB::island::%{_loc::1}%_%{_loc::2}%_%{_loc::3}%::leader}
					add 1 to y-coord of {_bedrock}
					set {SB::player::%{_uuid}%::island::home::home} to {_bedrock}
					
					set {_l::1} to {_bedrock}
					set {_l::2} to {_bedrock}
					add ({SB::config::distance} - {SB::config::protect}) to x-coord of {_l::1}
					add ({SB::config::distance} - {SB::config::protect}) to z-coord of {_l::1}
					subtract ({SB::config::distance} - {SB::config::protect}) from x-coord of {_l::2}
					subtract ({SB::config::distance} - {SB::config::protect}) from z-coord of {_l::2}
					set y-coord of {_l::1} to 256
					set y-coord of {_l::2} to 0
					#
					# > Creates the borders again. 
					set {SB::player::%{_uuid}%::island::border1} to {_l::1}
					set {SB::player::%{_uuid}%::island::border2} to {_l::2}
				stop
				
			#
			# > Argument: "kickall"
			# > If the user types in /islandadmin island kickall, all players of the current island are kicked.
			# > Actions:
			# > Kicks everyone on the island the player is currently at without deleting it.
			if arg-2 is "kickall":
				#
				# > "kickok" is a argument which is used by a tellraw prompt to accept if it
				# > should really kick all players on that island.
				if arg-3 is "kickok":
					#
					# > Set the leader and if the leader is existing, kick everyone from the island
					set {_leader} to arg-4 parsed as offline player
					if {_leader} is set:
						set {_uuid} to uuid of {_leader}
						set {_bedrock} to {SB::player::%{_uuid}%::island::bedrock}
						set {_locx} to x-coord of {_bedrock}
						set {_locy} to y-coord of {_bedrock}
						set {_locz} to z-coord of {_bedrock}
						#
						# > Loop trough all members and also delete them from the list
						loop {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::member::*}:
							set {_player} to loop-value parsed as offline player
							leaveisland({_player}, "member")
							delete {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::member::%loop-index%}
						leaveisland({_leader}, "owner")
						set {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::leader} to "---"
						message "%{_prefix}% %{SB::lang::isadmin::kickall::%{SK::lang::%uuid of player%}%}%"
				set {_bedrock} to searchbedrock(player)
				if y-coordinate of {_bedrock} is -5:
					#
					# > Prints the defined spacers and a message that the island could not be found:
					#
					message "%{SB::config::spacer}%"
					message "%{_prefix}% %{SB::lang::isinfonotfound::%{SK::lang::%uuid of player%}%}%"
					message "%{SB::config::spacer}%"
				else:
					set {_loc::1} to x-coord of {_bedrock}
					set {_loc::2} to y-coord of {_bedrock}
					set {_loc::3} to z-coord of {_bedrock}
					#
					# > Ask the user if everyone should be kicked, the user has to click on the tellraw prompt
					# > to accept it, it runs another command which is going to kick all members.
					set {_user} to {SB::island::%{_loc::1}%_%{_loc::2}%_%{_loc::3}%::leader} parsed as offline player
					
					#
					# > Create a tellraw if everyone should be kicked from the island
					set {_a} to {SB::lang::isadmin::kickallprompt::%{SK::lang::%uuid of player%}%}
					replace all "<player>" with "%{_user}%" in {_a}
					set {_prefix} to "%{_prefix}% %{_a}%"
					set {_msg} to "%{SB::lang::isadmin::yes::%{SK::lang::%uuid of player%}%}%"
					tellrawmsg1(player,{_prefix},{_msg},"/islandadmin island kickall kickok %{_user}%")

			#
			# > Argument: "changebiome"
			# > If the user types in /islandadmin island changebiome <biome>, the biome of the current island is changed.
			# > Optional: Define the owner of the island to take it instead of the current island.
			# > Actions:
			# > Changes the biome of the island the user is standing on or the defined 4nd argument.
			if arg-2 is "changebiome":
				set {_player} to arg-4 parsed as offline player
				if {_player} is not set:
					set {_bedrock} to searchbedrock(player)
					if y-coordinate of {_bedrock} is -5:
						#
						# > Prints the defined spacers and a message that the island could not be found:
						message "%{SB::config::spacer}%"
						message "%{_prefix}% %{SB::lang::isinfonotfound::%{SK::lang::%uuid of player%}%}%"
						message "%{SB::config::spacer}%"
						stop
				else:
					#
					# > The 4nd argument is valid, set it to the bedrock to get the leader.
					set {_uuid} to uuid of {_player}
					set {_bedrock} to {SB::player::%{_uuid}%::island::bedrock}

				set {_loc::1} to x-coord of {_bedrock}
				set {_loc::2} to y-coord of {_bedrock}
				set {_loc::3} to z-coord of {_bedrock}
				#
				# > Get the leader from the bedrock location variable
				set {_user} to {SB::island::%{_loc::1}%_%{_loc::2}%_%{_loc::3}%::leader} parsed as offline player
				#
				# > Print information to the admin that the biome is changed.
				message "%{SB::config::spacer}%"
				set {_a} to {SB::lang::bc::changing::%{SK::lang::%uuid of player%}%}
				replace all "<biome>" with arg-3 in {_a}
				message "%{_prefix}% %{_a}%"
				message "%{SB::config::spacer}%"
				#
				# > Run the function to change the biome.
				changebiome({_user},arg-3,arg-3)
			if arg-2 is "changeleader":
				if arg-4 is "changeok":
					if arg-5 is set:
						set {_newowner} to arg-3 parsed as offline player
						set {_oldowner} to arg-5 parsed as offline player
						set {_oldowneruuid} to uuid of {_oldowner}
						set {_newowneruuid} to uuid of {_newowner}
						
						if {SB::player::%{_newowneruuid}%::island::leader} is not {_oldowneruuid}:
							message "%{_prefix}% %{SB::lang::isadmin::newleaderhastobemember::%{SK::lang::%uuid of player%}%}%"
							stop
						#
						# > Gets the bedrock of the old leader and takes the locations out to get members later
						set {_bedrock} to {SB::player::%{_oldowneruuid}%::island::bedrock}
						set {_locx} to x-coord of {_bedrock}
						set {_locy} to y-coord of {_bedrock}
						set {_locz} to z-coord of {_bedrock}
						
						#
						# > Changes the leader uuid of the old leader entry
						set {SB::player::%{_oldowneruuid}%::island::leader} to {_newowneruuid}
						set {SB::player::%{_newowneruuid}%::island::leader} to {_newowneruuid}
						
						#
						# > Changes the leader of this island to the new leader
						set {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::leader} to {_newowneruuid}

						#
						# > Adds the old owner to the members list
						add {_oldowneruuid} to {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::member::*}
						#
						# > Loop trough all members and change it to the new owner
						loop {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::member::*}:
							set {SB::player::%loop-value%::island::leader} to {_newowneruuid}
							if loop-value is {_newowneruuid}:
								delete {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::member::%loop-index%}
								
						#
						# > Print the message about the new leader
						set {_a} to {SB::lang::isadmin::newleader::%{SK::lang::%uuid of player%}%}
						replace all "<newleader>" with "%{_newowner}%" in {_a}
						replace all "<oldleader>" with "%{_oldowner}%" in {_a}
						message "%{_prefix}% %{_a}%"
						stop
				#
				# > If the 4th argument was not "changeok", do the following code:
				set {_bedrock} to searchbedrock(player)
				if y-coordinate of {_bedrock} is -5:
					#
					# > Prints the defined spacers and a message that the island could not be found:
					message "%{SB::config::spacer}%"
					message "%{_prefix}% %{SB::lang::isinfonotfound::%{SK::lang::%uuid of player%}%}%"
					message "%{SB::config::spacer}%"
				else:
					set {_loc::1} to x-coord of {_bedrock}
					set {_loc::2} to y-coord of {_bedrock}
					set {_loc::3} to z-coord of {_bedrock}
					
					set {_user} to {SB::island::%{_loc::1}%_%{_loc::2}%_%{_loc::3}%::leader} parsed as offline player
					
					#
					# > Prints a promt if the leader should be changed
					set {_a} to {SB::lang::isadmin::changeleader::%{SK::lang::%uuid of player%}%}
					replace all "<newleader>" with arg-3 in {_a}
					replace all "<oldleader>" with "%{_user}%" in {_a}
					set {_prefix} to "%{_prefix}% %{_a}%"
					set {_msg} to "%{SB::lang::isadmin::yes::%{SK::lang::%uuid of player%}%}%"
					tellrawmsg1(player,{_prefix},{_msg},"/islandadmin island changeleader %arg-3% changeok %{_user}%")

			#
			# > Argument: "invite"
			# > Invites a player for the owner of the island
			# > Actions:
			# > This is going to invite a player, like it would have been done by the owner directly.
			# > Use addmember to add a member without asking the user.
			if arg-2 is "invite":
				#
				# > Set the argument 3 to a offline player (owner)
				set {_o} to arg-3 parsed as offline player
				if {_o} is a offline player:
					#
					# > The invited player has to be online
					set {_p} to arg-4 parsed as offline player
					if {_p} is online:
						#
						# > Use the uuid of the player with a local variable
						set {_ouuid} to uuid of {_o}
						#
						# > Check if the owner actually owns a island
						if {SB::player::%{_ouuid}%::island::leader} is set:
							if {SB::player::%{_ouuid}%::island::leader} is {_ouuid}:
								set {_arg2} to {_p}
								if {_arg2} is online:
									if {_arg2} is not {_o}:
										set {_p2} to {_arg2}
										set {_tuuid} to uuid of {_p2}
										#
										# > If the invited player is already on an island, print error
										if {SB::player::%{_tuuid}%::island::leader} is set:
											set {_msg} to {SB::lang::alreadyotheris::%{SK::lang::%uuid of player%}%}
											replace all "<player>" with "%{_p2}%" in {_msg}
											message "%{_prefix}% %{_msg}%"
											stop
										#
										# > If everything is ok, send a invitation tellraw and wait for x seconds,
										# > then stop it, if not accepted.
										set {_uuid2} to uuid of {_arg2}
										set {_b} to {SB::lang::gotrequest::%{SK::lang::%{_uuid2}%}%}
										message "%{_prefix}% %{SB::lang::sentrequest::%{SK::lang::%uuid of player%}%}%"
										replace all "<player>" in {_b} with "%{_o}%"
										message "%{_prefix}% %{_b}%" to {_p2}
										set {_uuidp2} to uuid of {_p2}
										set {_msg} to {SB::lang::clicktojoin::%{SK::lang::%{_uuidp2}%}%}
										replace all "<player>" with "%{_o}%" in {_msg}
										tellrawmsg1({_p2},{_prefix},{_msg},"/is join %{_o}%")
										set {_cooldown} to {SB::config::invitecooldown}
										set {_cooldown} to {_cooldown} parsed as number
										set {Request::%{_arg2}%::%{_o}%} to {_cooldown}
										while {Request::%{_arg2}%::%{_o}%} > 0:
											subtract 1 from {Request::%{_arg2}%::%{_o}%}
											wait a second
										if {Request::%{_arg2}%::%{_o}%} is 0:
											delete {Request::%{_arg2}%::%{_o}%}
											set {_a} to {SB::lang::reqtoleader::%{SK::lang::%uuid of player%}%}
											set {_c} to {SB::lang::reqtoleader::%{SK::lang::%{_ouuid}%}%}
											set {_uuid2} to uuid of {_arg2}
											set {_b} to {SB::lang::reqtomember::%{SK::lang::%{_uuid2}%}%}
											message "%{_prefix}% %{_a}%"
											message "%{_prefix}% %{_c}%" to {_o}
											message "%{_prefix}% %{_b}%" to {_p2}
									else:
										set {_a} to {SB::lang::cantinviteself::%{SK::lang::%uuid of player%}%}
										message "%{_prefix}% %{_a}%"
								else:
									set {_a} to {SB::lang::playeroff::%{SK::lang::%uuid of player%}%}
									message "%{_prefix}% %{_a}%"
							else:
								set {_a} to {SB::lang::notleader::%{SK::lang::%uuid of player%}%}
								message "%{_prefix}% %{_a}%"
						else:
							message "%{_prefix}% %{SB::lang::nois::%{SK::lang::%uuid of player%}%}%"
		#
		# > If no argument has been used, tell the player what is possible:
		else:
			message "/isadmin island invite <Owner> <New Player> - Invite player to the island"
			message "/isadmin island changeleader <New Owner> - Change the leader of the island on which you're standing to the new owner (has to be a member)"
			message "/isadmin island changebiome <new biome> [<Owner>] - Changes the biome for the island you're standing on or the defined owner"
			message "/isadmin island kickall - kicks everyone from the island you're standing on"
			message "/isadmin island addmember <player> - adds the defined player to the island you're currently at, if no leader is set, the player gets the leader"
			message "/isadmin island calc <player> - calculates the island of the defined player"


command /island [<text>] [<text=1>] [<text>]:
	aliases: /is, /sb, /skyblock
	trigger:
		set {_prefix} to {SB::lang::prefix::%{SK::lang::%uuid of player%}%}
		if arg-1 is not set:
			skyblockgui(player)
		if arg-1 is "reload":
			if player has permission "%{SB::config::buildpermission}%":
				make player execute "/sk reload SkyBlock/"
		if arg-1 is "create":
			if {SB::player::%uuid of player%::island::leader} is set:
				message "%{_prefix}% %{SB::lang::alreadyis::%{SK::lang::%uuid of player%}%}%"
				stop
			if player is online:
				if arg-2 is "1":
					#todo translation
					open chest with 1 rows named "&6Inseln" to player
					set {_s} to 0
					#go trough all available schematics or structures, which where set in the config.sk and post it here:
					loop {SB::schematics::schematic::*}:
						set {_item} to grass named "%{SB::schematics::name::%{SK::lang::%uuid of player%}%::%loop-index%}%"
						make gui slot {_s} of player with {_item} to run player command "/is create %loop-value%"
						add 1 to {_s}
					delete {_s}
					delete {_Bla::*}
					stop
				else:
					#check, if defined schematic exists:
					if {SB::config::isstorage} is "Schematic":
						if file "plugins/WorldEdit/schematics/%arg-2%" exists:
							#security check, is this schematic within the config:
							set {_ok} to false
							loop {SB::schematics::schematic::*}:
								if loop-value is arg-2:
									set {_ok} to true
							#not found, print error and stop:
							if {_ok} is "false":
								send "&c&lError"
								stop
						#file doesnt exist, print error and stop:
						else:
							send "&c&lError"
							stop
					#if there is no schematic, don't do anything for now
					else:
						set {_ok} to true
			actionload(player,"start")
			while {SB::searchprocess} is true:
				wait 10 ticks
			if {SB::searchis::%player%} is set:
				message "%{_prefix}% %{SB::lang::waitis::%{SK::lang::%uuid of player%}%}%"
				stop
			else:
				set {SB::searchis::%player%} to true
			set {_loc} to location at 0.5, {SB::config::height}, 0.5 in "%{SB::config::world}%" parsed as world
			set {SB::searchprocess} to true
			set {_search} to true
			set {_s} to 1
			set {_l} to 1
			set {_option3} to {SB::config::distance} parsed as number
			while {_search} is true:
				loop {_l} times:
					if {_s} is 1 or 5:
						add ({SB::config::distance}*2) to Z-coord of {_loc}
					if {_s} is 2:
						add  ({SB::config::distance}*2) to X-coord of {_loc}
					if {_s} is 3:
						subtract  ({SB::config::distance}*2) from Z-coord of {_loc}
					if {_s} is 4:
						subtract  ({SB::config::distance}*2) from X-coord of {_loc}
					if block at {_loc} is not bedrock:
						message "%{_prefix}% %{SB::lang::foundis::%{SK::lang::%uuid of player%}%}%"
						delete {SB::searchis::%player%}
						add 1 to y-coord of {_loc}
						set {_schematic} to arg-2
						set {_backloc} to player's location
						subtract 1 from y-coord of {_loc}
						set block at {_loc} to barrier
						add 1 to y-coord of {_loc}
						teleport player to {_loc}
						wait 5 ticks
						set {_loccx} to "%x-coord of {_loc}%"
						set {_loccy} to "%y-coord of {_loc}%"
						set {_loccz} to "%z-coord of {_loc}%"
						replace all ".5" with "" in {_loccx}
						set {_loccx} to {_loccx} parsed as integer
						replace all ".5" with "" in {_loccy}
						set {_loccy} to {_loccy} parsed as integer
						replace all ".5" with "" in {_loccz}
						set {_loccz} to {_loccz} parsed as integer
						if {_loccx} < 0:
							set {_loccx} to {_loccx}-1
						if {_loccz} < 0:
							set {_loccz} to {_loccz}-1
						set {_chestloc} to {_loc}
						set {_homeloc} to {_loc}
						if {SB::config::isstorage} is "Structure":
							execute console command "/setblock %{_loccx}% %{_loccy}% %{_loccz}% minecraft:structure_block[mode=load]{name:""%{_schematic}%"",posX:-16,posY:-1,posZ:-16,rotation:""NONE"",mirror:""NONE"",mode:""LOAD""} destroy"
							wait 5 ticks
							subtract 1 from y-coord of {_loc}
							execute console command "/setblock %{_loccx}% %{_loccy}-1% %{_loccz}% minecraft:redstone_block"
							wait 5 ticks
						else if {SB::config::isstorage} is "Schematic":
							#todo add functions for worldedit.
							broadcast "Schematic is not working right now"
							stop
						#HOME start
						set {_temphomeloc::*} to {SB::schematics::loc::%{_schematic}%::home} split at ","
						loop {_temphomeloc::*}:
							set {_temphomeloc::%loop-index%} to {_temphomeloc::%loop-index%} parsed as integer
						set x-coordinate of {_homeloc} to x-coordinate of {_homeloc} + {_temphomeloc::1}
						set y-coordinate of {_homeloc} to y-coordinate of {_homeloc} + {_temphomeloc::2}
						set z-coordinate of {_homeloc} to z-coordinate of {_homeloc} + {_temphomeloc::3}
						#HOME end
						#CHEST start
						#Gets the configurated schematic chest location and places a chest there:
						set {_tc::*} to {SB::schematics::loc::%{_schematic}%::chest} split at ","
						loop {_tc::*}:
							set {_tc::%loop-index%} to {_tc::%loop-index%} parsed as integer
						set x-coordinate of {_chestloc} to x-coordinate of {_chestloc} + {_tc::1}
						set y-coordinate of {_chestloc} to y-coordinate of {_chestloc} + {_tc::2}
						set z-coordinate of {_chestloc} to z-coordinate of {_chestloc} + {_tc::3}
						set block at {_chestloc} to chest
						set {_newchest} to block at {_chestloc}
						loop {SB::schematics::chest::%{_schematic}%::*}:
							set {_data::*} to loop-value-2 split at ","
							set {_titem} to "%{_data::2}%" parsed as item
							set {_tamount} to {_data::1} parsed as integer
							add {_tamount} of {_titem} to {_newchest}'s inventory
						#CHEST end
						set {SB::searchprocess} to false
						#If something went wrong, teleport player back to backloc variable
						if block at {_loc} is not bedrock:
							teleport player to {_backloc}
							send "&c&o/is create"
							stop
						set {_b} to block at {_loc}
						set {_pis} to {_loc}
						add 1 to y-coord of {_pis}
						delete {_search}
						actionload(player,{SB::lang::foundis::%{SK::lang::%uuid of player%}%})
						teleport player to {_homeloc}
						remove blindness from player
						remove slowness from player
						set {_l::1} to {_loc}
						set {_l::2} to {_loc}
						set {_option4} to {SB::config::protect} parsed as number
						add ({SB::config::distance} - {SB::config::protect}) to x-coord of {_l::1}
						add ({SB::config::distance} - {SB::config::protect}) to z-coord of {_l::1}
						subtract ({SB::config::distance} - {SB::config::protect}) from x-coord of {_l::2}
						subtract ({SB::config::distance} - {SB::config::protect}) from z-coord of {_l::2}
						set y-coord of {_l::1} to 256
						set y-coord of {_l::2} to 0
						set {_x} to x-coord of {_loc}
						set {_y} to y-coord of {_loc}
						set {_z} to z-coord of {_loc}
						set {SB::island::%{_x}%_%{_y}%_%{_z}%::leader} to uuid of player
						set {SB::island::%{_x}%_%{_y}%_%{_z}%::level} to 1
						set {SB::island::%{_x}%_%{_y}%_%{_z}%::exp} to 0
						set {SB::island::%{_x}%_%{_y}%_%{_z}%::created} to now
						set {SB::player::%uuid of player%::island::bedrock} to location at {_x}, {_y}, {_z} in "%{SB::config::world}%" parsed as world
						set {SB::islvl::%{_x}%_%{_y}%_%{_z}%} to 0
						
						add 1 to y-coord of {_loc}
						set {_y} to y-coord of {_loc}						
						set {SB::player::%uuid of player%::island::leader} to uuid of player
						set {SB::player::%uuid of player%::island::home::home} to {_homeloc}
						
						set {_x} to x-coord of {_l::1}
						set {_y} to y-coord of {_l::1}
						set {_z} to z-coord of {_l::1}
						set {SB::player::%uuid of player%::island::border1} to location at {_x}, {_y}, {_z} in "%{SB::config::world}%" parsed as world
						set {_x} to x-coord of {_l::2}
						set {_y} to y-coord of {_l::2}
						set {_z} to z-coord of {_l::2}
						set {SB::player::%uuid of player%::island::border2} to location at {_x}, {_y}, {_z} in "%{SB::config::world}%" parsed as world
						stop loop
					wait a ticks
				if {_s} is 6:
					set {_s} to 2
				else:
					add 1 to {_s}
				if {_s} is 3 or 5:
					add 1 to {_l}
		#
		# > Argument "flag" ("flags")
		# > Actions:
		# > Opens the flag menu using the openflagmenu function.
		else if arg-1 is "flag" or "flags":
			openflagmenu(player)
		#
		# > Argument "tp"
		# > Actions:
		# > Teleports the executor to the island of the argument 2, if the flags are set to true.
		else if arg-1 is "tp":
			#
			# > If argument 1 is empty, it is always "1".
			if arg-2 is not "1":
				#
				# > Set argument 2 as offline player and get the uuid.
				set {_p2} to arg-2 parsed as offline player
				set {_uuid2} to uuid of {_p2}
				#
				# > Get the bedrock of the argument 2 (player)
				set {_bedrock} to {SB::player::%{_uuid2}%::island::bedrock}
				set {_x} to x-coord of {_bedrock}
				set {_y} to y-coord of {_bedrock}
				set {_z} to z-coord of {_bedrock}
				#
				# > Check, if the executor is allowed to teleport to the island.
				loop {SB::island::%{_x}%_%{_y}%_%{_z}%::trust::*}:
					#
					# > If the user is trusted, teleport:
					if "%loop-value%" is "%uuid of player%":
						teleport player to {SB::island::%{_x}%_%{_y}%_%{_z}%::home::home}
						stop
				#
				# > Check the flags, maybe the island is public:
				if {SB::island::%{_x}%_%{_y}%_%{_z}%::flag::publichome} is set:
					if {SB::island::%{_x}%_%{_y}%_%{_z}%::flag::publichome} is false:
						message "%{_prefix}% %{SB::lang::flag::errorfalse::%{SK::lang::%uuid of player%}%}%"
						stop
				#
				# > If there is no custom flag, there might be a default flag:
				else:
					if {SB::config::defaultisflag::publichome} is false:
						message "%{_prefix}% %{SB::lang::flag::errorfalse::%{SK::lang::%uuid of player%}%}%"
						stop
				#
				# > Since this hasn't stopped yet, it is valid to teleport the executor.
				teleport player to {SB::island::%{_x}%_%{_y}%_%{_z}%::home::home}

			else:
				#
				# > There is no player, print error.
				message "%{_prefix}% %{SB::lang::notfoundplayer::%{SK::lang::%uuid of player%}%}%"
		#
		# > Argument: "home"
		# > Actions:
		# > If the player wants to teleport to a home, the homehandler is called.
		# > Example command /island home [<name>]
		else if arg-1 is "home":
			homehandler(player,"home",arg-2)
		#
		# > Argument: "sethome"
		# > Actions:
		# > If the player wants to set a home, the homehandler is called.
		# > Example command /island sethome [<name>]
		else if arg-1 is "sethome":
			homehandler(player,"sethome",arg-2)
		#
		# > Argument: "delhome"
		# > Actions:
		# > If the player wants to delete a home, the homehandler is called.
		# > Example command /island sethome [<name>]
		else if arg-1 is "delhome":
			homehandler(player,"delhome",arg-2)
		else if arg-1 is "go":
			if {SB::player::%uuid of player%::island::bedrock} is not set:
				message "%{_prefix}% %{SB::lang::nois::%{SK::lang::%uuid of player%}%}%"
			else:
				set {_loc} to {SB::player::%uuid of player%::island::bedrock}
				add 1 to y-coordinate of {_loc}
				teleport player to {_loc}
				message "%{_prefix}% %{SB::lang::tpis::%{SK::lang::%uuid of player%}%}%"

		else if arg-1 are "delete" or "remove":
			if {SB::player::%uuid of player%::island::bedrock} is not set:
				message "%{_prefix}% %{SB::lang::cantleave::%{SK::lang::%uuid of player%}%}%"
			else:
				#If the 2. argument is 2, then delete, else, create a tellraw which executes this command with the 2. argument.
				if arg-2 is "2":
					set {_uuid} to uuid of player
					set {_bedrockloc} to {SB::player::%{_uuid}%::island::bedrock}
					set {_x} to x-coordinate of {_bedrockloc}
					set {_y} to y-coordinate of {_bedrockloc}
					set {_z} to z-coordinate of {_bedrockloc}
					if difference between {SB::island::%{_x}%_%{_y}%_%{_z}%::created} and now < {SB::config::deletecooldown}:
						message "%{_prefix}% %{SB::lang::cooldown::%{SK::lang::%uuid of player%}%}%"
					else:
						deleteisland(player)
				else:
					tellrawmsg1(player,{_prefix},{SB::lang::isdeleteqestion::%{SK::lang::%uuid of player%}%},"/is delete 2")

		else if arg-1 is "calc":
			if {SB::player::%uuid of player%::island::bedrock} is not set:
				message "%{_prefix}% %{SB::lang::nois::%{SK::lang::%uuid of player%}%}%"
				stop
			#If there is more time between the las calculation and now than the set cooldown time in config.sk:
			if difference between {SB::calcdown::%uuid of player%} and now < {SB::config::calccooldown}:
				message "%{_prefix}% %{SB::lang::cooldown::%{SK::lang::%uuid of player%}%}%"
			else:
				set {SB::calcdown::%uuid of player%} to now
				set {SB::calcstatus::%player%} to 1
				make player execute "/is calcwait"
				$ thread
				calcisland(player)
		else if arg-1 is "calcwait":
			if {SB::calcstatus::%player%} is set:
				actionload(player,"start")
				while {SB::calcstatus::%player%} is set:
					wait 10 ticks
				set {_uuid} to uuid of player
				set {_bedrockloc} to {SB::player::%{_uuid}%::island::bedrock}
				set {_x} to x-coordinate of {_bedrockloc}
				set {_y} to y-coordinate of {_bedrockloc}
				set {_z} to z-coordinate of {_bedrockloc}
				set {_level} to {SB::island::%{_x}%_%{_y}%_%{_z}%::level}
				actionload(player,"&rLevel: &6&l%{_level}%")

		else if arg-1 is "top":
			if {SB::islvl::*} is set:
				loop {SB::islvl::*}:
					set {_loc::*} to loop-index split at "_"
					set {_loc::1} to {_loc::1} parsed as number
					set {_loc::2} to {_loc::2} parsed as number
					set {_loc::3} to {_loc::3} parsed as number
					set {_uuid} to {SB::island::%{_loc::1}%_%{_loc::2}%_%{_loc::3}%::leader}
					set {_level} to {SB::island::%{_loc::1}%_%{_loc::2}%_%{_loc::3}%::level}
					set {_exp} to {SB::island::%{_loc::1}%_%{_loc::2}%_%{_loc::3}%::exp}
					set {_Level::%{_uuid}%} to {_level}
				loop {_Level::*}:
					add 1 to {_size}
					if {_low.to.high.list::%loop-value%} is not set:
						set {_low.to.high.list::%loop-value%} to loop-index
					else:
						set {_n} to 0
						loop {_size} times:
							set {_n} to {_n}+1
							{_low.to.high.list::%loop-value-1%.%{_n}%} is not set
							set {_low.to.high.list::%loop-value-1%.%{_n}%} to loop-index
							stop loop
				wait 1 tick
				set {_n} to size of {_low.to.high.list::*}
				loop {_low.to.high.list::*}:
					set {_high.to.low.list::%{_n}%} to loop-value
					set {_n} to {_n}-1
				wait 1 tick
				set {_page} to 1
				loop {_high.to.low.list::*}:
					add 1 to {_result}
					add 1 to {_r}
					set {_Top::%{_page}%::%{_r}%} to loop-value
					if loop-value is player:
						set {_rank} to {_r}
					else:
						loop {_Member::%loop-value%::*}:
							if loop-value-2 is player:
								set {_rank} to {_r}
					if {_result} is 10:
						set {_result} to 0
						add 1 to {_page}
				set {_arg1} to arg-2 parsed as number
				if {_arg1} is not set:
					message "%{_prefix}% %{SB::lang::notanumber::%{SK::lang::%uuid of player%}%}%"
					stop
				else:
					if {_top::%{_arg1}%::*} is not set:
						message "%{_prefix}% %{SB::lang::pagenotfound::%{SK::lang::%uuid of player%}%}%"
						stop
				if {_Rank} is not set:
					set {_rank} to "-/-"
				message "%{SB::config::spacer}%"
				send "%{SB::lang::prefix::%{SK::lang::%uuid of player%}%}%&6&l &eTop 10 &6&l(%arg-2%/%{_page}%)"
				loop {_Top::%arg-2%::*}:
					set {_member} to ""
					set {_loc} to {SB::player::%loop-value%::island::bedrock}
					set {_locx} to x-coord of {_loc}
					set {_locy} to y-coord of {_loc}
					set {_locz} to z-coord of {_loc}
					loop {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::member::*}:
						set {_tp} to "%loop-value-2%" parsed as offline player
						if {_member} is "":
							set {_member} to "%{_tp}%"
						else:
							set {_member} to "%{_member}%, %{_tp}%"
					set {_p} to "%loop-value%" parsed as offline player
					if player is {_p}:
						set {_rank} to loop-index
					send  "&e&l%loop-index%&8 - &a%{_p}%&8&l: &e%{_Level::%loop-value%}% &7||&8 %{_Member}%"
				set {_size} to size of {SB::islvl::*}
				send "%{SB::lang::prefix::%{SK::lang::%uuid of player%}%}% &eDu bist auf Platz %{_rank}% von %{_size}% Inseln. todo: translate"
				message "%{SB::config::spacer}%"
			else:
				message "%{_prefix}% %{SB::lang::nois::%{SK::lang::%uuid of player%}%}%"
		else if arg-1 is "level" or "lvl":
			if {SB::player::%uuid of player%::island::bedrock} is not set:
				message "%{_prefix}%  %{SB::lang::nois::%{SK::lang::%uuid of player%}%}%"
			else:
				set {_loc} to {SB::player::%uuid of player%::island::bedrock}
				set {_locx} to x-coord of {_loc}
				set {_locy} to y-coord of {_loc}
				set {_locz} to z-coord of {_loc}
				set {_level} to {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::level}
				set {_p} to {SB::lang::prefix::%{SK::lang::%uuid of player%}%}
				message "%{SB::config::spacer}%"
				message "%{_p}%%{SB::lang::levelheader::%{SK::lang::%uuid of player%}%}%%{_level}%" to player
				message "%{_p}% Calculate your level with /is calc -todo: translation" to player
				message "%{SB::config::spacer}%"
				set metadata value "IS-Level" of player to "%{_level}%"
		else if arg-1 is "spawn" or "lobby":
			teleport player to {SB::config::spawn}
		else if arg-1 is "invite":
			if {SB::player::%uuid of player%::island::bedrock} is set:
				if {SB::player::%uuid of player%::island::leader} is uuid of player:
					set {_arg2} to arg-2 parsed as offline player
					if {_arg2} is online:
						if {_arg2} is not player:
							set {_p2} to {_arg2}
							set {_tuuid} to uuid of {_p2}
							if {SB::player::%{_tuuid}%::island::border1} is set:
								set {_msg} to {SB::lang::alreadyotheris::%{SK::lang::%uuid of player%}%}
								replace all "<player>" with "%{_p2}%" in {_msg}
								message "%{_prefix}% %{_msg}%"
								stop
							set {_uuid2} to uuid of {_arg2}
							set {_b} to {SB::lang::gotrequest::%{SK::lang::%{_uuid2}%}%}
							message "%{_prefix}% %{SB::lang::sentrequest::%{SK::lang::%uuid of player%}%}%"
							replace all "<player>" in {_b} with "%player%"
							message "%{_prefix}% %{_b}%" to {_p2}
							set {_uuidp2} to uuid of {_p2}
							set {_msg} to {SB::lang::clicktojoin::%{SK::lang::%{_uuidp2}%}%}
							replace all "<player>" with "%player%" in {_msg}
							#todo  the function could execute the console command by itself, there is no need to do it this way
							tellrawmsg1({_p2},{_prefix},{_msg},"/is join %player%")
							set {_cooldown} to {SB::config::invitecooldown}
							set {_cooldown} to {_cooldown} parsed as number
							set {Request::%{_arg2}%::%player%} to {_cooldown}
							while {Request::%{_arg2}%::%player%} > 0:
								subtract 1 from {Request::%{_arg2}%::%player%}
								wait a second
							if {Request::%{_arg2}%::%player%} is 0:
								delete {Request::%{_arg2}%::%player%}
								set {_a} to {SB::lang::reqtoleader::%{SK::lang::%uuid of player%}%}
								set {_uuid2} to uuid of {_arg2}
								set {_b} to {SB::lang::reqtomember::%{SK::lang::%{_uuid2}%}%}
								message "%{_prefix}% %{_a}%"
								message "%{_prefix}% %{_b}%" to {_p2}
						else:
							set {_a} to {SB::lang::cantinviteself::%{SK::lang::%uuid of player%}%}
							message "%{_prefix}% %{_a}%"
					else:
						set {_a} to {SB::lang::playeroff::%{SK::lang::%uuid of player%}%}
						message "%{_prefix}% %{_a}%"
				else:
					set {_a} to {SB::lang::notleader::%{SK::lang::%uuid of player%}%}
					message "%{_prefix}% %{_a}%"
			else:
				message "%{_prefix}% %{SB::lang::nois::%{SK::lang::%uuid of player%}%}%"
		else if arg-1 is "join":
			set {_arg2} to arg-2 parsed as offline player
			if {_arg2} is "1":
				loop {Request::%player%::*}:
					set {_tplayer} to loop-index parsed as offline player
					set {_msg} to {SB::lang::clicktojoin::%{SK::lang::%uuid of player%}%}
					replace all "<player>" with "%{_tplayer}%" in {_msg}
					tellrawmsg1(player,{_prefix},{_msg},"/is join %{_tplayer}%")
				if size of {Request::%player%::*} is 0:
					message "%{_prefix}% %{SB::lang::norequest::%{SK::lang::%uuid of player%}%}%" to player
				stop
			else if {_arg2} is set:
				if {Request::%player%::%{_arg2}%} is set:
					if {SB::player::%uuid of player%::island::bedrock} is set:
						message "%{_prefix}% %{SB::lang::alreadyis::%{SK::lang::%uuid of player%}%}%"
						set {_check} to {SB::player::%uuid of player%::island::leader}
						if {_check} is uuid of player:
							message "%{_prefix}% %{SB::lang::havetodelete::%{SK::lang::%uuid of player%}%}%"
						else:
							message "%{_prefix}% %{SB::lang::havetoleave::%{SK::lang::%uuid of player%}%}%"
					else:
						#todo - add a function which adds a member to the island with 2 agruments?
						set {_uuid} to uuid of {_arg2}
						set {_loc} to {SB::player::%{_uuid}%::island::bedrock}
						set {_locx} to x-coord of {_loc}
						set {_locy} to y-coord of {_loc}
						set {_locz} to z-coord of {_loc}
						add uuid of player to {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::member::*}
						set {_pluuid} to uuid of {_arg2}
						set {_joinuuid} to uuid of player
						set {SB::player::%{_joinuuid}%::island::bedrock} to {SB::player::%{_pluuid}%::island::bedrock}
						set {SB::player::%{_joinuuid}%::island::leader} to {SB::player::%{_pluuid}%::island::leader}
						set {SB::player::%{_joinuuid}%::island::home::home} to {SB::player::%{_pluuid}%::island::home::home}
						set {SB::player::%{_joinuuid}%::island::border1} to {SB::player::%{_pluuid}%::island::border1}
						set {SB::player::%{_joinuuid}%::island::border2} to {SB::player::%{_pluuid}%::island::border2}
						delete {Request::%player%::%{_arg2}%}
						make player execute command "/is home"
						set {_a} to {SB::lang::joinedismember::%{SK::lang::%uuid of player%}%}
						set {_uuid2} to uuid of {_arg2}
						set {_b} to {SB::lang::joinedisleader::%{SK::lang::%{_uuid2}%}%}
						replace all "<arg-2>" in {_a} with "%{_arg2}%"
						replace all "<player>" in {_b} with "%player%"
						message "%{_prefix}% %{_a}%"
						set {_p2} to {_arg2}
						message "%{_prefix}% %{_b}%" to {_p2}
				else:
					set {_a} to {SB::lang::norequest::%{SK::lang::%uuid of player%}%}
					message "%{_prefix}% %{_a}%"
			else:
				set {_a} to {SB::lang::invitetargeterror::%{SK::lang::%uuid of player%}%}
				message "%{_prefix}% %{_a}%"
		else if arg-1 is "leave":
			if {SB::player::%uuid of player%::island::bedrock} is not set:
				message "%{_prefix}% %{SB::lang::nois::%{SK::lang::%uuid of player%}%}%"
			else:
				if {SB::player::%uuid of player%::island::leader} is uuid of player:
					message "%{_prefix}% %{SB::lang::leaderleaveinfo::%{SK::lang::%uuid of player%}%}%"
				else:
					if arg-2 is player:
						message "%{_prefix}% %{SB::lang::deletekickmember::%{SK::lang::%uuid of player%}%}%"
						leaveisland(player, "member")
					else:
						message "%{_prefix}% %{SB::lang::leftis::%{SK::lang::%uuid of player%}%}%"
						leaveisland(player, "owner")
		
		# > Argument: "kick"
		# > If a player types in /island with the first argument "kick" and the second argument with the player name of the
		# > player who should get kicked, then the following code is investigating if the user has an island, is the owner of his island,
		# > has a member by that name on his member list and then fire the "leaveisland" function, if the player was found.
		else if arg-1 is "kick":
			if {SB::player::%uuid of player%::island::bedrock} is not set:
				message "%{_prefix}% %{SB::lang::nois::%{SK::lang::%uuid of player%}%}%"
			else:
				if {SB::player::%uuid of player%::island::leader} is uuid of player:
					if arg-2 is set:
						set {_kickplayer} to arg-2 parsed as offline player
						set {_uuid} to uuid of {_kickplayer}
						set {_loc} to {SB::player::%uuid of player%::island::bedrock}
						set {_locx} to x-coord of {_loc}
						set {_locy} to y-coord of {_loc}
						set {_locz} to z-coord of {_loc}
						loop {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::member::*}:
							if loop-value is uuid of {_kickplayer}:
								delete {SB::island::%{_locx}%_%{_locy}%_%{_locz}%::member::%loop-index%}
								set {_a} to {SB::lang::kickmemberleader::%{SK::lang::%uuid of player%}%}
								set {_b} to {SB::lang::kickmember::%{SK::lang::%{_uuid}%}%}
								set {_p2} to arg-2 parsed as offline player
								replace all "<arg-2>" in {_a} with arg-2
								replace all "<player>" in {_b} with "%player%"
								message "%{_prefix}% %{_a}%"
								leaveisland({_p2}, "member")
								stop
						set {_a} to {SB::lang::plnotfound::%{SK::lang::%uuid of player%}%}
						replace all "<player>" with arg-2 in {_a}
						message "%{_prefix}% %{_a}%"
					else:
						set {_a} to {SB::lang::invitetargeterror::%{SK::lang::%uuid of player%}%}
						message "%{_prefix}% %{_a}%"
				else:
					actionload(player,{SB::lang::noperm::%{SK::lang::%uuid of player%}%})
		else if arg-1 is "help":
			set {_site} to arg-2 parsed as integer
			if {_site} is more than 4:
				message "%{_prefix}% %{SB::lang::helpsiteerror::%{SK::lang::%uuid of player%}%}%"""
				stop
			send "%{SB::config::spacer}%"
			if arg-2 is "1":
				message "%{_prefix}% %{SB::lang::iscreate::%{SK::lang::%uuid of player%}%}%"
				message "%{_prefix}% %{SB::lang::isdelete::%{SK::lang::%uuid of player%}%}%"
				message "%{_prefix}% %{SB::lang::isteleport::%{SK::lang::%uuid of player%}%}%"
				message "%{_prefix}% %{SB::lang::issethome::%{SK::lang::%uuid of player%}%}%"
				message "%{_prefix}% %{SB::lang::isteleportgo::%{SK::lang::%uuid of player%}%}%"
			else if arg-2 is "2":
				message "%{_prefix}% %{SB::lang::islevel::%{SK::lang::%uuid of player%}%}%"
				message "%{_prefix}% %{SB::lang::istop::%{SK::lang::%uuid of player%}%}%"
				message "%{_prefix}% %{SB::lang::isinvite::%{SK::lang::%uuid of player%}%}%"
				message "%{_prefix}% %{SB::lang::iskick::%{SK::lang::%uuid of player%}%}%"
				message "%{_prefix}% %{SB::lang::isjoin::%{SK::lang::%uuid of player%}%}%"
			else if arg-2 is "3":
				message "%{_prefix}% %{SB::lang::isleave::%{SK::lang::%uuid of player%}%}%"
				message "%{_prefix}% %{SB::lang::isgui::%{SK::lang::%uuid of player%}%}%"
				message "%{_prefix}% %{SB::lang::isspawn::%{SK::lang::%uuid of player%}%}%"
				message "%{_prefix}% %{SB::lang::isore::%{SK::lang::%uuid of player%}%}%"
				message "%{_prefix}% %{SB::lang::isgen::%{SK::lang::%uuid of player%}%}%"
				message "%{_prefix}% %{SB::lang::isbiome::%{SK::lang::%uuid of player%}%}%"
			else if arg-2 is "4":
				message "%{_prefix}% %{SB::lang::trustadd::%{SK::lang::%uuid of player%}%}%"
				message "%{_prefix}% %{SB::lang::trustremove::%{SK::lang::%uuid of player%}%}%"
				message "%{_prefix}% %{SB::lang::trustlist::%{SK::lang::%uuid of player%}%}%"
				message "%{_prefix}% %{SB::lang::flaglist::%{SK::lang::%uuid of player%}%}%"
			send "%{_prefix}% &7%{SB::lang::helps2::%{SK::lang::%uuid of player%}%}%: %{_site}%/4 - %{SB::lang::helpsiteerror::%{SK::lang::%uuid of player%}%}%" to player
			send "%{SB::config::spacer}%"

		# > Argument: "info"
		# > If a player types in /island info, the the following code is being executed.
		# > Actions:
		# > Starts the "searchbedrock" function with the player as argument, if the return location is is not at y-coordinate -5, go forward.
		# > Then it takes the location apart in x, y, z coordinates and gets all the variables from the main location of the island, where the
		# > Bedrock is placed at and displays the data.
		#
		else if arg-1 is "info":
			set {_bedrock} to searchbedrock(player)
			if y-coordinate of {_bedrock} is -5:
				#
				# > Prints the defined spacers and a message that the island could not be found:
				#
				message "%{SB::config::spacer}%"
				message "%{_prefix}% %{SB::lang::isinfonotfound::%{SK::lang::%uuid of player%}%}%"
				message "%{SB::config::spacer}%"
			else:
				set {_loc::1} to x-coord of {_bedrock}
				set {_loc::2} to y-coord of {_bedrock}
				set {_loc::3} to z-coord of {_bedrock}
				
				set {_uuid} to {SB::island::%{_loc::1}%_%{_loc::2}%_%{_loc::3}%::leader} parsed as offline player
				set {_level} to {SB::island::%{_loc::1}%_%{_loc::2}%_%{_loc::3}%::level}
				set {_exp} to {SB::island::%{_loc::1}%_%{_loc::2}%_%{_loc::3}%::exp}
				set {_created} to {SB::island::%{_loc::1}%_%{_loc::2}%_%{_loc::3}%::created}
				#
				# > Go trough all members and add them as a player to a new array.
				#
				loop {SB::island::%{_loc::1}%_%{_loc::2}%_%{_loc::3}%::member::*}:
					add "%loop-value%" parsed as offline player to {_member::*} 
				#
				# > Prints the defined spacer:
				#
				message "%{SB::config::spacer}%"
				#
				# > Prints the header:
				#
				message "%{_prefix}% %{SB::lang::isinfo::%{SK::lang::%uuid of player%}%}%"
				#
				# > Prints the leader of the island:
				#
				message "%{_prefix}% %{SB::lang::isleader::%{SK::lang::%uuid of player%}%}% %{_uuid}%"
				#
				# > Prints the members, if there is at least one member:
				#
				if size of {_member::*} is not 0:
					message "%{_prefix}% %{SB::lang::ismember::%{SK::lang::%uuid of player%}%}% %{_member::*}%"
				#
				# > Prints the island info:
				#
				message "%{_prefix}% %{SB::lang::isinfolevel::%{SK::lang::%uuid of player%}%}% %{_level}%"
				#
				# > Prints the creation date of the island:
				#
				message "%{_prefix}% %{SB::lang::iscreated::%{SK::lang::%uuid of player%}%}% %{_created}%"
				#
				# > Prints the defined spacer:
				#
				message "%{SB::config::spacer}%"
		#
		# > Argument: "generator" ("gen" OR "oregen" OR "oregenerator")
		# > If a player types in /island generator, his current generator level is displayed
		# > Actions:
		# > Gets all the broken blocks and calculates the final level the player is currently on and
		# > also display a visual appealing status, how far the next level is away. This is done in a function.
		#
		else if arg-1 is "generator" OR "gen" OR "oregen" OR "oregenerator":
			generatorinfo(player)

		#
		# > Argument: "generator" ("gen" OR "oregen" OR "oregenerator")
		# > If a player types in /island ores, his current chances are displayed
		# > Actions:
		# > Gets all the ore generator chances for the player
		#
		else if arg-1 is "ores" OR "ore" OR "orechances" OR "chances":
			orechancesinfo(player)

		#
		# > Argument: "trust"
		# > If a player types in /island trust, the trusthandler function is called.
		# > Actions:
		# > Calls the trusthandler function, which either lists all options, adds someone as
		# > trusted or removes a trusted user, also can list all trusted users.
		else if arg-1 is "trust":
			trusthandler(player,arg-2,arg-3)

		#
		# > Argument: "upgrade" ("upgrades")
		# > If a player types in /island upgrade, the islandupgrademenu function is called.
		# > Actions:
		# > Calls the islandupgrademenu function, which opens the upgrade menu.
		else if arg-1 is "upgrade" or "upgrades":
			islandupgrademenu(player)
